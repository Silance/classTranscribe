[{"text":"Hello! Let's talk about automatic variables","width":121},{"text":"so here's my main method I've got two function calls f1 f2","width":274},{"text":"and today I'm going to actually define them before my main method","width":313},{"text":"so I don't need to put in the additional declares in","width":228},{"text":"so let's have f1 here and f2...ok","width":367},{"text":"so now I've got a syntactically correct program","width":188},{"text":"but I want to talk about the variables that we might put inside these","width":219},{"text":"so if I create a variable like this to say \"hey I've got a value here, something I need to compute inside f1\" or maybe I want to make an array","width":770},{"text":"and here's my array and I can initialize it to, say, \"f1f1\" here we go","width":408},{"text":"then the lifetime of my array (this variable) is only for the lifetime of the function","width":546},{"text":"when I return from f1, then the variable goes out of scope","width":326},{"text":"which means the name \"array\" doesn't mean anything anymore inside our program","width":214},{"text":"but secondly, the memory that we were using for the array is automatically free'd up","width":343},{"text":"it can be reused for other purposes in a moment by the rest of the program","width":220},{"text":"so isn't that fantastic","width":106},{"text":"that's why it's called an automatic variable","width":125},{"text":"so automatic variables are very easy to use","width":165},{"text":"they also come with a big warning sticker and that's this","width":289},{"text":"which is to be very wary of just how long they live for","width":237},{"text":"let's do a couple of things here","width":306},{"text":"first of all, let's make it so that we can actually see the pointer in memory where array is pointing to","width":696},{"text":"so, let's print that out inside our function here","width":293},{"text":"remember that the name of the array (when converted to address) gives us the very beginning of the array","width":444},{"text":"and, we'll do that for our second function too","width":172},{"text":"okay, so, f2 f2","width":179},{"text":"just to prove that they're making different arrays","width":178},{"text":"okay, so we'll compile and run this","width":190},{"text":"and, when we run it, we see that both f1 and f2 both these functions the array is actually stored inside the same memory location","width":915},{"text":"isn't that fantastic. we didn't need any additional memory","width":188},{"text":"and that's because after we return from f1, any of those automatic variables are free'd so they are no longer needed so we can reuse that space","width":576},{"text":"internally, later we'll discover that a stack data structure is used to implement his","width":440},{"text":"and I can show a little bit of this by having a either a recursive function or we can make another function call these","width":672},{"text":"for example, I could have a function called eg","width":365},{"text":"and, this calls f1","width":195},{"text":"so now let's have a look in the case that I'm not using f2 anymore","width":385},{"text":"so that can go away","width":119},{"text":"instead, I've got a function called eg and that can say have its own space","width":407},{"text":"so, blah and maybe say a thousand and twenty four bytes here","width":590},{"text":"and then we call f1 again","width":142},{"text":"so let's run this now","width":243},{"text":"so, in the output, you'll see that f1 is printed twice and the second time it's because it's being called from our function eg","width":985},{"text":"and in this case, it's further down in the stack. it's in lower memory","width":339},{"text":"f948 as opposed to fd50","width":196},{"text":"because it's being called from eg","width":274},{"text":"so, we'll see more about the stack in a moment","width":162},{"text":"later on. I just wanted to show you that they really are stored in different places","width":323},{"text":"finally, to reinforce this idea, let's make a little recursive function","width":341},{"text":"so, I can have something that takes an integer say I'll call it \"level\"","width":506},{"text":"and if level is greater than zero, let's call ourselves again with a slightly reduced value","width":667},{"text":"and I can of course make that simpler by just saying \"if level\"","width":331},{"text":"so if level is nonzero, then call it again","width":125},{"text":"and let's call it with say five","width":178},{"text":"okay, a semicolon would help","width":212},{"text":"each case as we go deeper and deeper into recursion, our array is getting lower and lower and lower in memory","width":671},{"text":"so we have all of these arrays created. all of these different activation records in different places","width":328},{"text":"inside our processes's memory","width":131},{"text":"so the last point we'll make, which is the most important, which is that it's very dangerous to return pointers to memory that is no longer valid","width":555},{"text":"for example, rather than returning nothing, suppose we try to return a pointer to our array","width":585},{"text":"and though this code might compile, okay, I can get rid of \"level\" now","width":416},{"text":"it's certainly not a valid program because the pointer we get back from f1 now points to stale memory","width":827},{"text":"that memory is no longer ours to control","width":167},{"text":"it will be used in a moment for other function calls","width":182},{"text":"so always be careful if you are returning a pointer to something. make sure that that memory is still valid","width":413},{"text":"and never return a pointer to an automatic variable","width":208},{"text":"that's it for me. time for you to play. bye!","width":195}]