So there are two more includes, and that's exactly the difference between this slide and the next slide, okay? The next slide shows exactly how those three files are organized. So just a couple of more includes with sphere.h and separation into three files.
Yes?
So if we have sphere.h, sphere.cpp, and a.cpp, would sphere.cpp need a name?
No, there is a way, a flag for the compiler to compile it not into an executable but into an object file. So, the process of compiling one file or many files like this is described in the Makefile tutorial that some of you maybe went through in your first lab (or maybe you didn't), but you should definitely refer to the tutorial. The compilation process is described very clearly there. In fact it's created by one of our staff members, it's a really good tutorial. It shows you how to compile different files into the same executable, so that these three files can be compiled into the same executable, which will do the same thing as the original .cpp program. You need to use certain flags to tell the compiler how to compile these into one executable.
However, by dividing them into three files, let me get back to that point, you are dividing the code into two different entities : the first two, sphere.h and sphere.cpp, is the implementing side. So it could be created by, say you were working for a company or a startup, and you are providing the product. You will be writing sphere.h and sphere.cpp; that is, you implement some class with some functionality. Sphere.h will be interfaced to it. You will be able to show the code for sphere.h to the client, but you hide the implementation details. So the client will never be shared the code of the .cpp file. This is a very useful property. So you show them what your class can do, but never show the secrets. Within the company itself, you can distribute who does what; so sphere.h could be written by one person, suppose a manager that knows exactly the client's needs, so he can write down what this function, this class, has to do. While the implementer, say the software engineer on this side, can write the implementation independently. But, he or she, has to follow the guidelines provided by the interface file sphere.h.
So again, it's a way to make it possible to write this code in a more collaborative way, but also a way to protect the implementation details and never give the code for this to the client. The client code can be written by whoever will be using the program provided by your company, and it can be written by a completely different person and your classes can be used just by looking at whatever functionality is provided in the .h file. Does that make sense?
Yes?
(inaudible)
So you precompile Makefile tutorial and, we'll talk a little more about encapsulation details later and what it means when you have these three files. Nevertheless, you precompile your sphere.h and sphere.cpp into an object; not quite an executable, but an object that provides machine code for all its implementations but does not contain the source code itself. So it's really neat, you give the .h file with declarations, and machine code with implementation, and taking those two, the client can then compile main.cpp. The Makefile tutorial helps explain that process. When you do it by Monday, we can talk about this further.
Okay, so that's one way.
Another way is to actually not put the implementations outside the class definition, but to put whatever's inside these curly brackets right here. Oh, that's setRadius, sorry. Right here, 