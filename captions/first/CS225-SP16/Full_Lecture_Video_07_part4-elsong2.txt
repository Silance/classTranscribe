And I'll put "by value" here because we will be passing that pointer by value. It's kind of very natural what is going to happen because we already know how to pass a struct by value so let's pass a pointer by value. So for that, and I didn't put any asterisks here because I wanted to show you something bad about this method; that is syntax. So let's see how many asterisks we will have to put here to make it work. So first, since I am gonna be working with the pointer, I'm gonna declare b now as a pointer. So after this declaration, what happens? This is my stack, variable b is created where? On this stack, its type is student pointer, what is the value of it, what is the address that it has? Garbage. Points who knows where? We don't know. Now we're gonna initialize this. I wanna make sure that instead of pointing to something that can be potentially bad, and lead to undefined behavior, I wanna point it to some nicely initialized stack variable without name, for student, and let's initialize it, please raise your hand if your name starts with a "b", what's your name, Bun, B-U-N, what's wrong, oh Ben, I'm sorry, it's really hard to hear from here, really. Ben, and you seem very happy. And what's your favorite age, "uhh, five". That's a new one. We had 120 in another lecture hall. I think120 is a really good age. Let's see what happens to Ben after we execute the next line. So we pass b, we pass the pointer to information about Ben by value to the birthday function. So s is gonna be coupled with b through the passing of the parameter. The question is, will the syntax like it is now, will it compile? No, why not? Type mismatch. Because the function signature expects a student and we send in a pointer. So we really have to fix it, we have to put asterisk here and there will be no type mismatch. We have to make sure there is no type mismatch in those assignments because essentially it's an assignment. And since b is passed by value, s become a local copy of b. What does this mean for s to be a local copy of b? What's its value then? An address of Ben, right? So being a local copy of a pointer means that its value is the same address, that means in the picture, it points to the same place. Fine. Let's work with it. Now I wanna increment age. s.age, it'll take s and try to find the member of s, but s is a pointer, it doesn't have members. It's a pointer, it's just an address. So have do we solve that? Dereference, and I will put parentheses there. I have a question to you, why didn't I do this?