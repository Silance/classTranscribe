We gave it back. It's not there, the system doesn't have control. Thus, that memory is free for use for other variables. So the question is: what's going to be the print out here then? What's the b.age? 20. B hasn't been changed. What's the d.age? What kind of garbage? I wanna run it, and show you that, it's going to be very interesting. Kind of garbage depending on what, on what I'm gonna actually do. How am I stack in that local function I'm gonna be using? Depending on that, it'll be different kind of garbage. So let me compile this. Ugh, where is it, ugh. Sorry. oh. So my compiler is nice. What it actually said, and we usually suppress those warnings for you, so that you have to figure it out. You can suppress warnings like that but it tells me, hey, you're returning a memory of a local variable. So probably something is gonna go wrong. So, I was warned, I've been warned, but I'm gonna run it anyway. It's 10! Why is it 10? Because whatever's going on the stack is going on this stack. Now, an interesting question: what if I don't have that variable y? I put it there just to mess up my stack. But, let me clean it up, let me comment it out, compile it. It's 20. Because there's less work that's done upon exiting and cleaning up the stack and probably another memory, that memory was reused in a different way. So one more thing: what if I actually didn't even do w, and did s all along? Because that's still a local variable, so it's still a wrong thing to do. Let's see if my stack is affected in a different way. Now it's 21. Because there's almost no work done so it actually still had that untouched w=s, with 21. It's called undefined behavior, right? Clearly, that's a demonstration of that. Sorry for the.. yeah. 