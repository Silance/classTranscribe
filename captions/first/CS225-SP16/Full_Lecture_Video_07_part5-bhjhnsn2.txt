The order of operation is first to take, by default if you don't put parentheses, it will try to still take the member variable of s, which doesn't exist, and then dereference that, which would be very wrong. So we have to explicitly put parentheses to say that, "First dereference and then take its age." Okay. Fine. So let's increment... let's dereference s and increment Ben's age to six. Question? Yeah. [unintelligible question] Dot is for member access so whatever you take a dot of has to be of user defined type. [unintelligible question] Oh, equivalent syntax, sorry. That's what I wanted to say here, too. Equivalently the same thing you could write s->age and these are two equivalent ways of writing the syntax. Saying that s is not a student. S is not of user defined type. S is a pointer, dereference it first and that will be student and take that member variable, age. Okay, it's just syntactically equivalent thing to do. So we incremented the age, we printed out birthday, we're gonna return, and let me put asterisk here again just to remind you that there's a lot of passing by... by pointer means a lot of asterisks. So now the function stopped executing it's gonna remove all of the local variables. What are the local variables? S is gonna be gone. So s gone, but we return the value six, right. That's the return that we're... return value integer value and assign it to new_age. Question. What's gonna be the printout of b.age? Compiler error, first of all. Right? B is a pointer, so let's fix that again. And then what's the output? Six. So what's good about it? It allows you to modify that data without copying it, which could be good or bad. You really have to be careful about it. Do you really want that function to have the control over your data? So that's something to keep in mind but in this case it's good. What else is good about it? Fast. It's fast. What's bad about it? Yeah. Can I say that sometimes you'll have pointers and you'll have nothing... no way around it, but bad thing is, what about writing all these asterisks? Some memory access. A lot of memory... um, sometimes could be slower than keeping that on the stack. However if you already had data on the heap, you would have to do it. So, but syntactically, syntactically, syntax complexity, which sometimes is unavoidable, but in this case, we could do better. Anything else that bothers you? S is a pointer, b is a pointer. What could could go wrong there when I dereference pointers?