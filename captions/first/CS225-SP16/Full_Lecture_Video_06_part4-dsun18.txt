Well, what I get? Yeah? Oh, man if my compiler is kind, if as part of compilation process variables are initialized, then I might get a 0, but I will be really lucky if I did. [gibberish] using Visual Studio C++ or something. You cannot count on it. So upon declaration even a static array just like every other variable you declare, you should assume has value, oh very good. We try that in harmony. [gibberish]. So upon declaration.. I don't need to write it, you got it. So now how do we initialize these values. Well, you are not gonna be surprised by any of these because these things are just arrays. I'm going to initialize all of them in one for loop. Like this. x sub i equals... we'll do this this time. And result will be value 0, 2, 4, 6, 8. Question about that? Yes. Well the answer is garbage. You don't know what value, you can't test, you can't.Say have I initialized this yet? That's why it's pretty good practice to upon declaring something, immediately give it a testable value. Alright, so this is garbage, this is the answer. Okay, what is the constraint that we said early on? This is great and I say great because we love stack variables.  Variables that we can argue or justifiably [gibberish] through the stack, that's good, right? This is great if size is known at compile time. And additionally if the sizes is not very big because you want to save your stack space for the execution of your program and not use it for data generally. Not too big. And furthermore the constraining part of this actually is that it will not change; hence the static piece of its naming. So known at compile time, it's not too big and it will not change. Okay what's the contrast? What's the contrast to this. These are dynamic arrays... Yeah you have a question? No I mean the size of the array. Size. No, you can certainly change the values, sorry. Yes. Sure. The value you can change. They are just like variables. They are just normal variables. But the size of the structure you can't. Okay, Was there another question? Yes. Compile time. That is a draw-back. So, luckily, we are not really constrained in that way, we can setup dynamic arrays. And these are arrays in the heap, that is the balk of memory is stored in the heap. Now, it probably won't surprise you, we still use a pointer to access heap memory, just like we did before. So, this declaration right here, this integer pointer whose name is x get set up in the stack, a30, x. Of course, its type I didn't specify here is a pointer, its value at first is garbage. Now here though is how we initiate x, we give it value. We call 'new'