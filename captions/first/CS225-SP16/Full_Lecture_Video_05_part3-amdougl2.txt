After that p is still a pointer to the same location, but that location now can be used for other variables. We told the system that you kind of got rid of it -- you cleaned it up. So with new it's kind of the opposite, with new you ask for a memory address and with delete you give it back. So deleting null pointers; what happens on deletion of q? Nothing. Nothing happens, you're allowed to do that. And you'll see that it's very helpful. So let's jump into examples of what really happens with bad behavior -- when we don't clean up memory nicely as we did with q. So let's look at other examples. Any questions about this? Yeah. [Student asks a question] If you what? Yeah. What happens? Ok if you don't assign null to the pointer after deleting it, then the following code will do that with that. So let's see what happens. So let's draw a picture again but, it will correspond to the situation when we don't null the pointer and try to work with it. So we have the stack and the heap.  We declare two variables: p and q. And so far they have garbage addresses as their values. For p we ask for new memory location on the heap of type integer and p is assigned that value. Then again the same line q is assigned the same memory address as p points to. And now we want to delete p. Which means that we tell the system follow the pointer and give that memory address back to the system for further use. So it's free'd. And the question is what happens if we try to dereference and print out q at this point. Um to make it a little more interesting, maybe I'm gonna say follow the pointer -- so asterisk q equals 8. Which will after assigning these pointers to the same memory address, it will also fill it out with integer value 8. So what happens here is the system will do something that will really do something that will really depend on what this random stuff is. If there's nothing there, that means there was nothing going on really after assigning to that memory address 8. Even though we deleted it, if we follow the pointer, it will most likely still be 8 because nothing else happened really in the program. No other variables were initialized, we didn't assign any other values to any pointers. Which means that the output of this will most likely be just 8. But the problem with this is that I don't really know. Ok. I couldn't guarantee that that something  forgettable will happen on execution of that code. That's why it's very important to set pointers to null after you free up the memory, because if you don't and somebody writes this kind of code. The behavior is unpredictable. And we call it an insidious bug. So this is very dangerous. You actually should not like this quite a bit. Let me give you an example of what kind of things can go wrong. What if I -- I printed out 8, I didn't set q or p to null. What if I -- what if I declared another point: say integer pointer r. And I asked the system for some new heap memory. With the new. 