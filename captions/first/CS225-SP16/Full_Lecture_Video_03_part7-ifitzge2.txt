And, implementation provides information and how it's done. So that's going to be useful. Here is a couple of a steps of second mechanism for encapsulation which is called separate compilation of objects. So this is the low its not that difficult it just may be a little confusing at this point. So if you ran through the makefile tutorial you probably know that the first step for compiling these three files into one executable is to compile. So first step is to compile .cpp of the object plus .h of the object into one .cpp fille. This is the first step. .cpp and .h file into one object file. That's the first step. That's fine. So we compile it into object file. So the second step is to compile main.cpp plus class interface into another object for main. So main object so at this point you can see that in order for main to compile it has to see the interface. In order for the implementation of the class to compile, it has to see the interface. So this eyes. However, there is an impenetrable wall between the class implementation and the client code. That is there is no way that client code can see the implementation of the class. and this is done through the two separate compilation of the objects. in order for main to compile it only needs to have .h included. it doesnt see the implementation. in order for the implementation of the class to compile. it only needs to see .h it doesn't need main for that. which means that first of all it provides protection of implementation of the class which could be intellectual property information. also when you write your client code, you should never assume that you know how things are implemented. you should only know what is implementation and in what interface and thats it. so thats also kind of a programmer's style of writing client code. and there is always a third link to create an executable. so in order to create an executable you need to link that of the class plus main.o for two objects and there will be an executable file. and im going to do it now in code but do you have questions about this concept. about two mechanisms for encapsulation. *question asked* all it needs is function signatures to compile into the object. so the compiler just needs to validify and call this function with this input parameters and will return this. does main seem proper syntactically? yes. fine. so all it needs is what sphere can do. not how exactly it assigns space. *question asked* step three it depends on. so the makefile tutorial sometimes it matters in which order you link them. in this case it does. okay so so lets see i want to just finish off the second point that separate completion of objects hides class implementation. 