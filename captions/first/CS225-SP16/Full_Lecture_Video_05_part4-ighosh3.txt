And now, put thirty-eight. So what might happen there is that, I'm sorry, it's a little loud, guys, it's very loud, I'm sorry, it really really disrupts me. Um, thank you. Okay so what may happen here, is that, the system said oh shoot, you ask for new memory, I can give it you, this chunk is not used anymore. So, I'm gonna assign r upon this assignment, that memory address, and I'll put thirty-eight in there, thirty-seven in there. Okay? So what if since, I don't know maybe somebody is using your code and wants to write the right things up and they see that, you know, pointer q is somewhere there, so what if they say well I'm going to dereference eight and put value eight there, I dereference q and put value eight there because I like that value in q, okay? And even though, at some point over here you freed up the memory for q, q is not null so I can dereference it. I can execute this line, follow the pointer and put eight back in there. Okay? And now, if somebody else wants to print out the value for r, what's gonna be the result of this? Eight, right? It will know that process or that function assigned thirty-seven to r clearly, and there is no way to see the connection between r and q because the system made that connection behind the scenes with new, right, with the new statement. That memory location was not used with new, it was assigned to r. Yeah? At the point where um, you're setting uh [gibberish]. What would happen, yes very good, let's lets, let's work through this, through that scenario. So after the case of delete where? [gibberish] After this one? What if we assign q to null, [gibberish] oh delete q again? Ohh. Oh that's interesting, delete q. So what's gonna happen up on this? It's gonna follow q, it's gonna free up that memory address to the system back, and then r, if you introducing yet another insidious bug. Because now r may not be pointing something you may think that you have control of the r pointer, but you don't anymore, somebody, the system may give back memory address yet again to another variable, so it's very dangerous. Yeah? [gibberish] How does the system? It keeps a list of all unused address, so how does the system know whether this address is used or not, it keeps a list, and with the new it gives the control of that address to your program, and with delete it takes it back on the list. [giberish] Yeah, yeah, sure. Yeah you can't, if you, if you ask keep asking for more and more addresses and you say don't delete them, you'll run out of heap memory, and there will be a runtime error. And we, I think in the end of your slides you see an example where you play with parameters, you're asking for a big string, and don't delete it so you're asking for new string and don't delete it, and if you do it one hundred thousand times, run it and see what happens. The system will say I don't have any memory to give you anymore, so it'll [gibberish], before a long time by the way, before it runs out of heap, yeah? [gibberish] Yeah it just takes that memory address and gives it back to the system, yeah, yeah? [gibberish] Is it a good reason why delete does not set that pointer that we just used to delete that memory to null. Yes there is a very good reason, because you might need, so I told you before that stack memory system controls it, but heap memory you're supposed to take good care of it. So here we go, these are the rules of taking good care of it, which means it may be a headache really. Debugging your code in MP2 in will be a headache, because you'll have to take good care of it, yeah. So that's by design, yeah? Yeah. [gibberish] I don't know that, I said hypothetically it could happen. So the question was when I declared r how do I know that that memory address was assigned to q which q q used to have a hold on? I don't know that's why it's insidious, it may not, it may or may not be the case. Okay on more question and then we'll move on. [gibberish]