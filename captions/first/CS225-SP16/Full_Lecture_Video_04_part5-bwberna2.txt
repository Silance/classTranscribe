So first we apply p to ampersand, and the result of this, if the input variable is p, ampersand returns what? a40. Is that a variable? It's a hex number, it's like 5. Can I take asterisk or apply anything to it? No. So the input type to asterisk will not match this type, It needs a variable of pointer type. Asterisk needs a variable of pointer type to look at value of that variable which a40 doesn't have. That's not a variable it's not even on the stack as a variable. It's a constant. The compiler will really complain about it and say "you passed something of not variable type to asterisk." You can try it I think we will have examples later that will run in a program. This is not compiled. I mean compiler error. [Student] If all pointers point to an address which is a hexadecimal constant, how does declaring a pointer p a certain type like that integer pointer or double point or something like that, why does that matter if the pointer itself is an address. [Professor] Of certain types it is very important, I think we wrote it down here, that we declared, yeah your right, the value will always be a constant but it has to match the declared type of that pointer. So it can be only an address of that type. Integer pointer can only have an address of integer type. Not sphere, it cannot point to sphere, it cannot point to circle, it cannot point to double. So that is why type is important in declaration. Does that answer your question?  [Student] Kind of. [Professor] The value of any pointer is a constant hex number, but the type. [Student] Right, is that because of how many bytes it takes from the stack.  [Professor] Yeah, there is more to that. Let's leave it at that because I do not want to talk about stack now, we will talk about it later. There are reasons for that, but let's talk after lecture because that is going into deep. Let's leave it at that, that the system somehow needs to know what that address points to at point just to verify that your intentions are good. Any questions? So, this example was kind of contrived because we have two variables connected through a pointer, both of them had names. So, we could access both of them directly through their names. There is another mechanism that allows you to access much bigger chunks of memory that is called heap memory. That will store the same things kind of like variable things but they will have no names, and will hold on to them through pointers. And that will given us a lot of flexibility, and it will all lead us to using arrays in C++. So, that is how we want to use this bigger chunk of memory that every program has access to store large sets, like arrays of different large objects. So how do we do that? We will start with a declaration of an integer pointer. The system will given the stack a chunk  memory of type integer pointer so we kind of commit to have an address here that  points to integer. And with name p and at certain location. And then if I want to ask for a heap memory, what I do is, I just say this. I want p to point to new integer. So, that is the syntax for it, and what the system will do it will first, well it's an assignment statement, so in the end we expect that p will get a value here. Which will be an address that stores an integer type. But let's see how the system does it, first of all it is the right hand side, and at the right side it says, oh there is a new keyword. Which means that you are asking for a chunk of memory on the heap and I will give it to you say b50. There will be no name because it is heap, there will be no names here. Even though these chucks are kind of like variables. And of type integer and there is no value associated with it yet, so it will be garbage what ever is there. And now return, so the return of this is address.