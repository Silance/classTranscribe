You could flag it so it's not changed, yea, but in this case, there will be another mechanism really.
Ya?
Jumping over ahead, it would call a destructor, which we didn't work really. depending how it's set up. Depends really. could be a lot of things going on when you call delete. Which is the next lecture, so we'll talk about it.
Okay, so the next one is parameter by reference, and let's see how it works. So I want a student remain to C, because I want to find a student whose name starts with C please.
Yes please. Charles. Okay so. C's a variable that is on this stack. So this is the stack. There is no heap really. We have Charles. You look serious. Go ahead. We have serious group today. What's your favorite age? 17 yes. That's nice.
Okay. umm, so lets see what happens when we do pass in by reference. So we set up C. We just set up C. We initialize it. We give the control to the birthday function, and we don't have to do anything except for flagging- giving a flag to the system - that in this case, is &. So when you see & in front of a variable, that would an address of operator. when you see an & in function signature, it's just a flag.
It's a flag that tells the system the following thing. it say's, hey, I want S to be just another name for C. that's what the flag is for. So whatever is passed as a parameter, I want it to get another name, that is a local name, but it is the same variable. So, how fast is this process of copying the name, Ya? Ya. So here in this case, the question was, this looks like a type mismatch. I'm passing a student to what looks like memory. because we're used to & indicating memory of, or address of. So no, but not in function signature. When you see & in function signature, it doesn't ask for memory address. It's just a flag saying that this variable is of the same type of student but I want it to be, but I want it to be an other name of the other variable. That's all. So another sentence for that would be, I could say, well, I have an integer x, which is 5, and I wanna, and on the stack it will just be x, with value 5, and I want another integer y, to be another name for x. That's how we do it. No address is nothing here. Just a flag saying, that's just an other name for x. So that's what happens here when we pass C to S. S and C are now just 2 names for the same thing. It's really cool. Do you think it's fast? Why? Underneath there are pointers assignments going on. Really, the system will actually do something with pointers on the stack. We don't need to know it. All we need to know is, that it's as fast as passing by pointers, but hey, they're no asterisk at all. So we're gonna get rid of all of the syntactic overhead here. Fine. So let's do this. Let's execute the function. Increment S is age. It's gonna take S, which is C, and increment the age to 18. We're gonna print out birthday, we're gonna return 18, and upon the exit from the function, we're gonna remove the local variable. What are the local variables? 



