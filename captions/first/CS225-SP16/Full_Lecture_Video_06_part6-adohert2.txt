In fact for MP2 for your second assignment, we ask you to implement a dynamic array whose size can change. Now its a little bit of a stretch to say, "Oh, you think you can change your size no big deal".  It is a big deal.  You still have to work hard to do it.  That is if your array is this size and you want it to be THIS size, you have to first allocate all that memory, copy these values over, and now you've got the bigger array.  Kay so, it isn't really like you can just wave a magic wand and its any size you want.  You still have to control the memory associated with your object.  But, at least you can.  At least you can resize it.  Okay, any questions about this? Yes. "So yeah there are about a gazillion ways of managing linear memory.  They all come at costs.  We are going to see extremes.  We are going to see the complete reallocation.  We are also going to see Linked Lists wherein every piece of memory you have a pointer to the next one.  And what you are kind of talking about sort of goes in between.  like lets take a chunk and then string chunks together.  But they come with complexity costs and possible sacrifice of performance in places you don;t suspect."  "So the question is If you are assigning space and you know that size too, and the answer is that all of those sizes can be determined at runtime rather than at compile time.  So you can take for example streaming data where you don't know how much you are going to get.  It is just going to keep coming at you and you have to have a place to just do it and in order to do so, you have to keep growing the amount of memory that you allocate to your structure.  Whereas there is no way to know ahead of time how much you are going to use."  Oh, you could allocate it all statically, but you better err on the size of large, which means you incur the cost of not using all of the memory that you are asking for, which has its own problems.  "So you write your code, and then you do Make, Make MP2.  That invokes the compiler.  That means, at that moment, you have to know how much memory you need.  When you say "a.out" or "a.exe Anna does".  That is runtime.  Now knowing at compile time how much memory you need means you cannot ask during execution "User, how big do you want your array to be today?" Or you cannot evaluate how big you want your array to be based on input data of any kind.  Okay you can't read in  a csv and say "Ok I need an array as big as my csv because you don't know how big your csv is.  Ok, does that help at all? "If you are really truly interested in performance, you are going to want to do that.  If you know there are 10 different majors in this class, might as well just have a static array, almost like a lookup table, of the 10 things people like to study in this class and be done with it.  Alright, anything else? We good? "Why can't the resizing be done on the stack?" - "Because the variable table contains the types and sizes of all the variables you are going to use in C++.  Essentially what you are doing here is you are making a new type of thing, so you could have a 10-array and a 5-array and a 5000-array, but they would all be there ahead of time taking up space and waiting for you to use them."  "Ok so the question is, If you declare an array on the stack and then you ask for input from the user, is that ok?  And the real answer is if you declare an array on the stack, it doesn't matter what that user says, that array is going to be the same size no matter what.  If you don't give it a size, it will allocate a huge one.