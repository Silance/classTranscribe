 We gave it back, its not that the system does not have control, thats the memory is free for use for other variables. So the question is what is going be the print out here then? What is the b's age? 20. B hasn't been changed. What is the d's age? What kind of garbage? I am going to run it and show you that it is going to be very interesting kind of garbage, depending on what, on what I am going to actually do, how much stack in that local function I am going to be using, depending on that, it will be different kind of garbage. So let me compile this. Ugh, where is it, ugh, sorry. So my compiler is nice, what it actually says and we usually suppress those warnings for you so that you have to figure it out. You can suppress warnings like that but it tells me "hey you are returning a memory of a local variable so probably something is going to go wrong". I was warned, I have been warned but I am going to run it anyway. Its 10! Why is it 10? Because whatever is going on the stack is going on the stack, now an interesting question, what if I don't have that variable y? I put it there just to mess up my stack. Let me clean it up, let me comment it out, compile it. It's 20! Because there is less work that is done upon on exiting and cleaning up the stack and probably another memory was reused in a different way. So one more thing, what if I actually did not even do w and did s all along? Because that still local variable so it is still a wrong thing to do. Let us see if my stack is effected in a different way. Now it is 21! Because there is almost no work done so it actually still had that untouched s. It is called undefined behavior right? Clearly, that is a demonstration of that. Sorry for the [delay].  