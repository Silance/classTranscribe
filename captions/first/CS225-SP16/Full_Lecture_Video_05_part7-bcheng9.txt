Type mismatch. It is is a pointer. OK, so here is a compiler error. But the intention of deleting that memory is just that in the first place. If you delete it in the first way, it will be a compiler error, if you type it into the second way, it's just wrong. OK? Umm, any question about this? OK. So there is no real good way to do this here right? If you have two variables, you don't want to give that addresses to the system if they are on the stack. OK, that's good. So now I'm gonna look at this code and I'm actually gonna run it. And see what kind of bad thing it may or may not happen here. So I have my main function. Let me match it with my slides. Integer x equals to 5. OK. And I want to find out a lot of things about this code. So. My drawing here is that I have a stack and a heap. I declare my variable p with initial garbage. Umm. Point to a value. Than I declare and give value 5 to a variable x. And then I set dereference p. Where is it gonna go? Garbages right? So let's draw that strange. For dereference, we did not really ask for any memory, we didn't assign the location, proper location. We didn't assign NULL there. But still dereference it and put x's value in there which is 5. So that's gonna be the drawing. And, as I said. There is nothing wrong with this code most of the times. Unless that garbage location is something bad. And let's see what's really is gonna be the output if I want to print out some of things of p and find out. So I wanna first find out where is p pointing. What do you think that's gonna be? And I wanna find out what p is. And I want to find out what is the address of p. OK? So these three things I gonna find out. But let's compile first. Do you think there is gonna be compilation problem? No. That's fine right. But upon execution, I want you to tell me what do you think is gonna be dereference p? Looking at our drawing. 5 right? It's gonna follow that pointer. wherever that is and give me the value. Since nothing really happens since I assign that value. That location may not have been overwritten right? Cool. What's gonna be p itself? That garbage address right? So we will see what that is. And what is gonna be the &p? That's gonna be the actual location of p on the stack, right? OK, so let's look at those. OK, so the first dereferencing, uh, p is fine. And it's 5 because you put 5 there but it may not have been, right? Or it may not have been fine to dereference it. It's a insidious bug. We don't know what could have been there. And that is garbage address, we can see what it is. It just may or may not be helpful. Umm, so that's really cool. What we gonna do next is, so the next slides are actually a ways for you to practice. It's the same problems that we already went through but it ran different outputs you can figure out what's gonna be the outputs. But. I want to go and start something different today because we are actually really well in the material. OK? We did really well so we can start looking at pointers with respect to the next topic which is gonna be the arrays. And I want to ask you to use the free space in your slides and help me with the following configuration in memory. So I want to write the code that will correspond to this memory configuration that I'm about to draw. So I want to have a pointer. I didn't know what that type is yet. You have to tell me. It's gonna point to an address on the heap with the integer value of 5. And I want to have another pointer that points to that stack location that's to that 5. And I want that to be q. And I want you to write the program that sets this up. So definitely there should be a q variable there and something else declarations and definitions. It takes like 2 minutes maybe and then you can tell me how to do that ok? 