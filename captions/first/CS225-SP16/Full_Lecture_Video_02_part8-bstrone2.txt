So there are two more includes, and, that's exactly the difference between this slide and the next slide, okay? The next slide shows exactly how those three files are organized. So just a couple of more includes with sphere.h, and separation to three files, yeah? No. There is a way applied for the compiler to not contain an executable, but to contain an object file. So, the process of compiling one file, or many files like this is described in the Makefile tutorial that some of you maybe went through in your first lab, or maybe you didn't but you were definitely referred to the tutorial. And the compilation process is described very clearly there. In fact it was created by one of our staff members, it's a really good tutorial. And it shows you how to compile different files into the same executable so, this default can be compiled into the same executable which will do exactly the same thing as my original program .cpp would, Okay? But then you'll just have to use certain flags to tell the compiler how to combine all of these into one. However, into one executable. However, by dividing them into the three files, let me get back to that point, you're dividing the code into two different entities. The first two, sphere.h and sphere.cpp, is the implementing side so it could be created by, say you are working for a company or a start up, and you're providing the product. You'll be writing sphere.h and sphere.cpp. That is you implement some class with some functionalities, sphere.h will be interface to it. You'll be able to show the code for sphere.h to the client, but you'll hide implementation details. So the client, you never share of the code of cpp files, okay? So this is a very useful property. So you show them what your class can do, but never show the secrets, right? Within the company itself, you can distribute who does what. So sphere.h could be written by one person and it could be manager, who knows exactly the clients needs, so what can write down what this function--what this class has to do. While the implementer, say software engineer on this side, can write implementation independently. But, he or she has to follow the guidelines provided by the interface class, interface file sphere.h, okay? So again, it's a way to make, to make it possible to write this code in a more collaborative way, but also it's a way to protect the implementation details and never give away the code for this to the client. And then the client, the client code can be written by whoever will be using the program provided by your company, and it can be written by a completely independent person, and your classes can be used just by looking at what are functionalities that are provided in .h file. Does that make sense? Yeah? So you precompile Makefile tutorial and we'll go about, we'll talk about encapsulation a little more in detail later. Um, and the way, what does it really mean that you have these three files? Nevertheless, you precompile your sphere.h and sphere.cpp into an object, that is not quite an executable but it's an object that provides machine code for all implementations, but you never give the code itself. So it's really neat. You give the .h file declarations and machine code with implementation, and then taking those two, the client can then compile main.cpp. Makefile tutorial definitely do that, it'll also explain the process. And then if you, when you do it by Monday we can talk about this incident further. Okay? So that's one way, another way is to actually not put implementations outside of the clause definition but put whatever's inside of these curly brackets right here. Oh that's set radius, sorry. Right here in--right here.