[Teacher]: that stores an integer. So you will return b40 and assign it to b. So i get b40 here, which essentially makes b point to that memory location. So now I have two variables, both of them can only be accessed through p. Very dangerous situation, right? What if something happens to p. P's on the stack, what if the system cleans it up . . . and I lose it? What will happen to that heap memory: and it will happen, and believe me it will happen to a lot of your Mp's in the future, and you will get [abrupt] if you do this often and lose that connection, that pointer to heap memory, you can just fill all of the heap memory up, and you'll run out of memory. If you do that sufficiently many times. And that is very difficult to track. So our goal, now, in this lecture and next lecture is to learn how to ask for memory on the heap, and also control it; clean it up when we don't need it anymore. Make sure that it's . . . that we take good care of it. Because as I said last time, heap memory is something that we have to take care of. So we have to ask for it, and then explicitly say, "oh I don't need that anymore, so clean it up." The system will not clean it up for us. So this is really, really cool. I want to show you something else, oh yeah, so the next step would be, well I said that p kind of holds information about two variables, one with name p, itself on the stack, and another one, this heap memory chunk, which means that I can . . . access it through asterisk right, and assign different values to it. So let's see what happens upon . . . this statement the right hand is constant of integer type, the left hand side is, follow the pointer, and the output is whatever variable is stored at that location, so this is essentially this variable, and assigned to two-hundred. Cool right? That's how we can populate values on heap. That's cool. So now if I say "cout asterisk p" the printout will be two-hundred. That's really cool. And, I want to show you something that . . . I want to show you how we will draw this situation okay? I want to start with drawings that we will always use through the rest of the semester when we work with pointers, because this is too much to draw, but drawings will really help us figure out, and find bugs, and yeah. [Student]: Do we know we're on the heap because of the new keyword? [Teacher] Yeah, new keyword is the giveaway that we are asking for memory on the heap. [Student] What's the advantage for having no names in the heap? [Teacher]: What's the advantage of having no names in the heap? That's how it is. You just can't. You access it through the pointer. So, that's how it is. Plus space, to store the names. [Student]: So is the new keyword, is that what gives us space in the heap? [Teacher]: Yes. New is specifically asking, new keyword is a giveaway for you that, okay this memory will be on the heap. Yeah? [Student unintelligible] . . . [Teacher] Ohhhh. Yeah, let's do that. Oh okay. So I executed, this is my main function, and now I say "p equals new int". Okay, let's do it. Let's go step by step with what's going to happen here. The right hand side says, the system says "oh you're asking for new location of type integer on the heap, I'm going to give it to you, here it is: b50, no name, type integer, not initialized to anything, so garbage so far, take the address. So the result of it is, so we know the right hand side evaluates to b50, so assign b50 to p. Okay? It's going to override b40 to b50. And suddenly our pointer points there. What just happened?