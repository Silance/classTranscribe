or by reference. And how you could indicate, or declare it to the system, that you intended to do that, well if it's by value just put the type. If it's by pointer by value you could type with an asterisk, that's how you tell it to the system, and if it's by reference, you put the type with the ampersand. That's just, a flag that says it's gonna be, just copy it in as another name to the right hand side. And let's go through the first one, and it's, it's very interesting, it's created some reaction last time. I really ask you to write this down if you have your computers just type it in, and I want to know your outputs are gonna be. So the main question is, what's gonna be the output here and here? So you can go ahead and try to do that. So this is gonna be returning by pointer by value. Because we've done returning by value in all of the previous examples. So let's look at it. I have a student b, who lives on the stack. And I populate, I initialize the values to Bill and the age 20, and then I declare a pointer, which lives (it's d) so it lives on the stack - originally points to some garbage or whatever location may be - it's valid but it's not a location to follow because we don't know what it is. We didn't ask for it, so instead so we're gonna assign, or initialize d through this assignment statement, which will be the assignment statement will be calling b and trying to implement the h. So we're gonna pass b - how do we pass b into s this time? By what? By value, which means a local copy on the stack of b is gonna be created. And I'm gonna go through exercise to show you it's two fold exercise. To show you how dangerous it is to not have control of memory, which you'll see what happens here, as well as just a reminder that copying is just so, slow. Because I'm gonna be doing a lot of copying here. So s is gonna get the value of b, local copy member wise. Then I'm declaring a student y on the stack initialized to garbage. Both values garbage fine. Now student y and, sorry, student w, and you'll have a question, why did I have it  assume y. And you'll see why, it's weird. Student w is copied member wise from s, so it's Bill again, and the age is twenty. Now I'm gonna increment w's age so it becomes twenty one. I'm gonna print out it's birthday, Bill's birthday, and I'm gonna return the address of w. So whatever that w student is stored in the stack, its address is gonna be returned. Is there any type mismatch? Am I returning what I promised I'd return? Pointer, an address, so it's fine. Is the right hand side of the return statement the same as the left hand side? So across the assignment there is no type mismatch. That means there's no problem right? There should be no problem. So what happens upon the termination? Local variables are removed so what are the local variables? Let's remove them. W, y, s, but the address of w is returned as the new value for d here. So d now is pointing now to an address, it's not something unknown, it's very well known, that the problem is is what?