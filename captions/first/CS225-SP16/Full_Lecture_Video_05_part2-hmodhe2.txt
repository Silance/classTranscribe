[Gibberish] to a piece of heap memory are what? Are removed for some reason right.. Removed. So we have this chunk of memory that doesn't have a name, has no pointer's pointing to it anymore. So there is no way way to get back to it and tell the system "Hey, you can take it back!"... Which we haven't done yet. Yep? [Student asking question]. Data Structures.. Custom Data Structures. This class about data structures. We are not in that topic yet. Please let's not jump yet! But I would be happy to talk about it after. But yes, we are.. this is a data structures class. We will be creating a lot of data structures over these things... like in three weeks. Yep? [Student asking question]. I initialized a pointer and never dereferenced and input anything into it... like what if? Example? Okay.. [gibberish].. Okay, I'm not taking anymore questions because that's like next examples that we'll go and ask to.. we'll go through that. Is that okay? Okay. Uhm, so.. we'll.. let's do this now. Uhm, so what happens here is that I didn't really handle this heap memory location well. I lost all references to it and I actually created a memory leak. So what... how would i do... or what would I do better to not.. to make sure that this doesn't happen to this memory address on the heap. I still have one pointer pointing to it. So I want to cleanly get rid of that memory. To do that, I have to say delete and give a pointer to the memory address that I want to give back to the system. Upon execution of this line, what will happen is that this memory location will be given back to the system and now system may assign it to another pointer as a value. So upon declaration of some new statement, this memory location may be given to that pointer again. Okay, so system can reuse this memory address now and we didn't lose it. The problem is that q still references.. so it still pointing to that memory location, right? And a good way to make sure... and that opens a door... the door for... to many many opportunities to create bugs. So if you gave some memory address back to the system and you still have pointers pointing it, that can cause many problems that again will have... uhm... we'll see what... what are the problems on the next slide. But in order to avoid that, you have to say q is equal to NULL which will... on our drawing, it will remove the value of q, which is currently pointing to that memory address which we just gave back to the system, and will reset it to NULL. So do you like this? How we handled q? We did handle it pretty well, right? We handled q pretty well. But we didn't handle p, well... enough. So once we are talking about NULL pointers, I want to see what happens if I work with them later. So if I have my q here, and I want to write the following statement. What if I want to dereference it and put some value in there? What do you think will happen. And this is the case of dereferencing a NULL pointer with an asterisk. Yep? [Student answers]. It's a segfault. So it's a very well defined behavior. If I didn't set up q to NULL and tried to dereference q after giving away that pointer... that address to the system. There could be lots of bad things... uhm, that would happen. However, if I set it to NULL, then I have a defined behavior and it's a run-time error: segmentation fault. What if I also say delete... if I don't like dereferencing q... so instead what if I try to attempt to delete memory or give back to the system, NULL? Yep? [Student asks question]. How do we use delete? [Student talking]. So what happens upon delete... delete is a... accepts a pointer to it. It looks at that pointer, follows it, looks at that location, and gives it back to the system.