it could segfault in case a pointer is what? NULL, or something is bad with pointer. So let me see, I'm a client, say, sorry, I'm a sub-contractor, and I'm writing this function, and I don't really know what is the intention of the user is. I'm just gonna write the function and maybe, for some reason, maybe for some reason right here, let me write it in the green code, in the green, um, color. Right here, right before the return statement, I wanna do the following. I wanna say delete s and I wanna say s equals to NULL. You know, I wanna clear out this memory. I don't know what the reasons would be here, but, I don't know. Why would you want to, you know. You want to let that memory to go to better place for some reason, I don't know. Maybe it's not a a birthday, right, something worse. Anyway, you get that memory back to the system, you NULL the pointer. What's bad about it? Yeah? [It doesn't point to anything] Yeah. There is no way- so if that's the intention, it's for some reason this function...I've, I've been to the funeral on Monday, so that's why I have, like, really bad ideas about relating this code to something, but what if for some reason, you know, that's...that's the end, right, and you want that memory to be gone, okay. So maybe you really want to do this, you want to free this memory, and you want to make that pointer to NULL because for some reason that person doesn't exist anymore. So, what can go wrong? And that's really wrong to do it. What could go wrong? What happens on the exec- Yeah? [Response] So, the, the reason is that, the moment we do it, let's trace it. We delete S so we give the memory back to the system it can reuse it, do, create, celebrate, other birthdays, right? Um, S is set to Null, that's good, dereferencing S would give us a, um, a segfault which is really good, but we could return 0 in that case because we could check if s is NULL. Once we're getting out of the system and we want to ask what happened to b, b is still pointing to that memory; b is not NULL. There is no way to set b to NULL from the inside of the birthday function if you a pass a pointer by value. There is no way to do that at all. There is no access to b at all, which means it's a really bad setup if you really wanna renew the pointer or set it to NULL. That's not the way to do that, and the thing is you'll have to do it later in the course when you work with trees. You'll have to reset sub trees to NULL and you will not do it by referencing pointer, eh um referencing parameters by pointers, you'll do it by referencing parameters by reference. Which is the - passing parameters by reference which is the next slide. Okay, so let's write down what we learned. Bad thing is syntax complexity, also, um, deleting memory from called functions won't work. So you need another mechanism. However the good news is it's really really fast. This is fast. We will not copy images, PNGs, at all. So the next method really combines all of the good things from the previous two and not have any of the bad. Um, yeah? [question] 