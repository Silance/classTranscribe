[gibberish] It's not there. The system doesn't have control, that's that memory is free for use for other variables. So the question is, what's gonna be the printout here then? What's the b's age? 20. B hasn't been changed. What's the d's age? What kind of garbage? I wanna run it, and show you that it's gonna be very interesting kind of garbage, depending on what, on what I'm gonna actually do. How my stack in that local function I'm gonna be using, depending on that, will be a different kind of garbage. So let me compile this. Ah, where is it, ah, sorry. So my compiler is nice. What it actually said, and we usually suppress these warnings for you, so that you have to figure it out. That you can suppress warnings like that, that tells me, "Hey, you're returning a memory of a local variable." So probably something's gonna go wrong. So I was warned, I've been warned but I'm gonna run it anyway. It's 10. Why's it 10? Because whatever's gone on the stack has gone on the stack. Now an interesting question: what if I don't have that variable y? I put it there just to mess up my stack. So alright, let me clean it up, let me comment it out, compile it. It's 20. Because there's less work that's done upon exiting and cleaning up the stack, and probably that memory was reused in a different way. So one more thing. What if I actually didn't even do w, and did s all along, because that's still a local variable, so it's still a wrong thing to do. Let's see if my stack is affected in a different way. Now it's 21, because there's almost no work done, so it actually still had that untouched double e s, with 21. It's called undefined behaviour, right? Clearly, that's a demonstration of that. Sorry for the... yeah.