find that location and insert value 8 into that location. OK? So the question is what happens if now I try to print out whatever is the value of de-reference p. What's gonna be the output, the result after executing that line will be? So what's gonna happen is that we're gonna try to follow the pointer of p and print out whatever that value stored in that location. Which is 8. Ok so this is all cool, this is nice, this is simple so far, right? So now we're going to do something so it kinda reviews what we learned last time. Now we're going to do some more interesting things with pointers. So the next line, I'm going to say well, you know, for q please give me another location on the stack, right? So I'm going to initialize another box. Oh on the heap sorry. So I'm going to initialize another box on the heap that doesn't have a name. It has a type integer and that address is going to be the new value given to q. Which means that it point anymore to that old location that's an old value of q and I'm going to give it a new value. A new address. And I'm going to follow the pointer q and put 9 in there. So far so good, right? And now I'm going to say OK, now p should be equal to null. What does that really mean? And I didn't talk about Null yet. Null is a memory address that is zero. So in hexadecimal format it's going to be just a zero. OK? And it's kind of like a zero for pointers. So integers have a zero; doubles have zero. Pointers have a zero and that's called null. We like to use it and I'll talk a lot about it today. But lets just leave it at that for now. So p is now going to have another value which is the zero address and not whatever it had before. So I'm going to draw it like this. I'm going to put a slash across the box for zero. And it doesn't have a pointer; it doesn't point to that location in heap memory. So the question is, do you like it? Why not? It's called memory, right? Um. Ok. So what's happened really to that old box on the heap... This location in memory does not have any pointers pointing to it anymore, right? However, we asked for it and we didn't explicitly give it back to the system so the system will not use it anymore and if you do this sufficiently many times say in the loop of 1 million times and you ask for heap memory again and again and again without giving it back you may run out of heap memory. It could be a run time error that you generate. So no. We don't like this. This is called memory leak. Let's right down the definition of memory leak if we understand it properly. Do you have a question, yeah? P equals to null, its not its pointing to yeah. So it's value is hexadecimal number which is 0. That is it's value is null. Does it point to that memory location? Yeah. The thing is that you cannot do much with it. You cannot really de-reference. It's more like a way to check whether your pointer initialized properly. Like its difficult to ask the system "hey is my pointer garbage?" How do you do that, how do you know, in the beginning, say, after the first line in your program, how would you know if we didn't really look at the code right here after the execution of this line, how would you know that it's garbage value? If you didn't do it yourself, if you didn't write that code yourself? But now there's, if somebody would assign it to null there would be a way to check "is this null or not?". But we'll have more better examples later. So it's a little bit jumping ahead. Yeah? If you don't say p equals to null... Nil integer? So is that C++? Null and you n-u-l-l? Oh new integer. Sorry. So if he is changing the statement to p equals to new integer. Yes. That also will cause a memory leak. That will be in an example in the next slide for that. OK? So no, we don't like this. Let's write down what a memory leak is. So memory leak occurs when... So I'll start it and please help me finish it. When all pointers... 