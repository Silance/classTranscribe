you guys are thinking way too hard. the heap past to function has insert and removed min. Remove min... etc.. until you are down. Remove the minimum, remove the next minimum, remove the next minimum. So, this is the sorting algorithm. I'm gonna talk about the benefit in just a minute. So the first thing you wanna do is with your data that came in unsorted. So this is given and unsorted array. First thing you wanna do is build the heap. Okay. Now. If I remove the minimum, if I remove A what am I gonna do with it where am I gonna put it? In front of some other array. Build it up. Now it will be fine. I don't wanna use the space so where is the room for A? If I remove A, if I pull A off, first thing I'm gonna do is get rid of w so I can use it to plug in for whole, So guess what. I have room for A so I'm gonna put it here. So do that again, remove it. Then B's gonna be here eventually then remove the minimum. We have room and B's gonna be here. This is a do a repeated remove min, keeping values in the structure. And then the last thing is you wanna reverse the order of your array if you want it to be an increasing order. What's the running time of each of the step? Running time of step 1 is big o of n. We just showed it. We almost showed it. Repeated remove min. Darn it. This is not better than n log n. And then to reverse the array is big o of n. The whole running time is big o nlogn. We don't need another one because this one is in place sort with worst case nlogn, whereas quicksort dosen't give you worst case nlogn. I have one last thing before you go because it's fun. Why did I choose this picture for our closing thought? it's a fun a picture but why is it for today? When you are together with your friend and you decided to make a human pyramid. Who goes on top? The lightest person. So this is like a physical representation of heap. We will talk about it next time. 