If two keys map to same small index, and by map to , I mean, the hash function. OK, any questions about all of that? Alright, so the first part of our focus is gonna send to our own hash table itself and second... first part of lecture will be sent to hash function itself, the second part will talk about collision resolution strategy. OK, collision resolution strategy. I have cold so. Alright, any question about all  these? Alright, so, hash functions, this is the story on hash function as I know it, it is going to necessarily be an incomplete story, because, guess what, there are people working for all kinds of different large entities sending their entire lives working on good hash functions. So, in this hour, we are not going to touch on all of the complexities involved with creating good hash functions. So it's people who are interested in cryptography are doing hash functions. Mathematicians, people who deal with data want really good hash functions with great characteristics. So this is just a glimpse into their world. There is a whole career out there  waiting for you centered on these materials if you would like. I am entreat by especially big data aspects of it. Alright, let's see , so what does a hash function look like, typically consists of two parts. A hash which takes the key and finds some integer, OK returns some integer, together with something that shrinks that integer down into a space small enough so that we can store it. So a compression, which is a function mapping that larger integer into the array. Cell 0 to N-1, and this is almost always and we will always be  for  our class just a mod function. This is mod N, where N is the table size. OK, any question about that? Alright, there is a yawn already. Who yawned? It is Friday, it is spreading I can yawn, too. OK, so it turns out that choosing a hash function is tricky. It is hard to choose a good one. And I am gonna to talk a little bit about that one and on the  next slide, there is a whole , again,  a whole lecture of what are some classic bad hash functions that have been created over time and extolled as next greatest thing for hash function and then found to contain peorisidities that actually result in really bad behavior, and we will talk about that in a minute. So we don't want you to create your own and yet it is not really well-stated, it should really be unless where the last thing you understand key space and small enough that you can create by bijection. Unless you can create by bijection . In which case, you should make your own hash function unless you know your data well enough to create a bijection. And notice that that really means also that your data has to be small enough that you can create this bijection. Alright, so what must a good, what characterizes a good hash function. So this are the characteristics of a good hash function. Computed in how much time? How much time will we get this function to run on a key. Constant time, that's right, very good, it must be computed in constant time. It must be deterministic. What is the opposite of deterministic? Probabilistic, yeah, good, or another word for that is? Random, right? So the opposite of deterministic in this case is random. Now , think about what  this means. What this means , here ,is  if I equals J, if index i is the same as index j, then it must be the case h of i is the same as h of j. OK, that is, there is no dice roll that says there is no dice roll that says what the hash of index should be , if we plug in 4 we are going to get the same value out every time we plug in 4. OK? Alright, we will talk about the what would happen  if that were broken in just a minute. OK, good hash function also satisfies the SUHA, I like saying it. And I will say it again and tell you what it means. SUHA. Simple, uniform, hashing assumption.