Checking to see if two vertices are adjacent, or whether an edge exists in the graph. Go looking, no choice but to traverse that edge list looking for two end points. Returning the set of incident edges for a given vertex. Again, this is boring. You have to go in search of them. Decidedly uninteresting. Another strategy; keep the vertex set at size n and edge set at size m, but add a table with a row for every vertex and a column for every vertex. This is a probably implemented as a 2 dimensional (2D) array. The data stored here would tell you the index of this row, for example. The implementation, you would connect this to this row in the table. Similarly for the column, you'd also have some index here that's specified by the column, it'll be the same column as row. There is going to be an entry in cell uv if uv exists in the graph. Now it turns out to be very convenient to instead of just a boolean indicator, to keep a pointer to the edge that actually exists. Then you can store data about that edge, so uw - is it there? Other things are just NULL. It's called an adjacency matrix. Running times of each of these functions given all of this structure. How long does it take to insert a vertex? What if the matrix is full? This is a 2 dimensional array. We need to be able to add a row and column to this matrix, and you know we're not stoopid. We're going to do it in such a way that we actually double the size (and copy the data). And the advertised cost for this (the cost of copying) is n squared (n^2). But we get n future adds for free, so the overall cost is going to be big O of n (O(n)) for re sizing. So periodically you have to do an expensive re size. How about removing a vertex? It's the same story. Actually. Let's remove v. How do I remove v from here?