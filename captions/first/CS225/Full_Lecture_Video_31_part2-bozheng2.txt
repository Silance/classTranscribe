If two keys map to same small index, and by map to I mean via the hash function. Ok, any question about all of that? Alright. So the first part of our focus is gonna center on the hash function itself, the second part will talk about collision resolution strategies on Friday.  Alright, any questions about all theres? Alright, so hash functions, this is the story on hash functions as I know it. It's going to necessarily be an incomplete story because guess what? There are people working on all kinds of different large entities spending their entire lives working on good hash functions. So in this hour, we are not going to touch on all of the complexities involved with creating good hash functions. So it's people who are interested in topographys are doing hash functions, mathematicians, people who deal with big data want really good hash functions with great characteristics. So this is just a glimpse to their world, there's a whole career there waiting for you centered on this material if you would like. I 'm intrigued by especially big data aspects of it. Alright, let's see. What is a hash function look like? Typically, consists of two parts: a hash which takes the key and finds some integer return some integer together with something that shrinks that integer down into a space small enough that we can store it. So a compression which is a function mapping that larger integer into the array, so zero to n-1, and this is almost always and it it will always be for our class just the mod function. This is mod  N , where N is the table size. Any question about that? OK, so turns out that choosing hash function is tricky, it's hard to choose good ones. and I will talk a little bit about it on the next slide. There's again a whole lecture of what our some classic bad hash functions that have been created over time and as the next greatest things for hash functions and then found to contain periodicity that actually results in very bad behavior, we will talk a little bit about that in a minute. So we don't want you to create your own. The "yet" is not really well stated. It should really be "unless". Where the unless is that you understand your key pace and it is small enough that you can create a bijection.  unless you can create a bijection in which case you should make your own hash function. unless you know your data, well enough, to create a bijection. and notice that really means also that your data has to be small enough that you could create this bijection. Alright,  so what characterizes a good hash function? So these are the characteristics of a good hash function. Computing how much time we are gonna give the function to run on the key? Constant time, that's right, very good. It must be computed in constant time. It must be deterministic. What's the opposite of deterministic? "Probablistic", or another word for that is random, tight? So the opposite of deterministic in this case is random. Now think about what this means. What this means here is if i==j, then it must be the case h(i)==h(j). there is no dice roll that says what the hash of the index should be. We plug in 4, we are gonna get the same value out every time. We'll talk about what would happen if that was broken in just a minute. good hash functions also satisfy the SUHA. I like saying it, and so I will say it again and I will tell you what it means SUHA. simple uniform hashing assumption. 