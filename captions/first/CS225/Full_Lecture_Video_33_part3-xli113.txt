OK,  so how long does it take to insert an unsorted list?  Unsorted list, I just want to be putting values in. How much time should that take? Oh, constant time! look at that! There is a mistake already. This should be constant time. Good. How about removeMin? Is order n correct? I want to find in an unsorted array the minimum value.  Yeah? That's fine, right? So, order n is correct. I would have to go on a hunt through the linear collection of data, looking for the minimum. Ok, fine, how about for a linked list? If we implemented this functionality in insert and removeMin, using a singling linked list. How much time would it to take to insert? Constant, but we want to put the new one back here, right? No, no reason to do so. It is unsorted, so when you insert, you would insert at the front. You can do this at constant time. Or, you have a tail pointer you can do it at the rear. Ok, fine. How about removeMin? Still big O of n? We would have to go search for it. OK, fine, let's suppose, we decided that we can fix this, we will fix this by using a sorted array. In that case, how long does it take to do an insertion? A sorted array. 2,3,4,8,13,21, and I want to insert 11. How much time does it take? Log(n) right? How come it is logn? why are we thinking logn? Binary search, very good. You observe the opportunity of binary search. So, we use binary search to determine the 11 goes here, but we have to shift the data. This is not true. Oh gosh! I swore when I came to school, today would be a better lecture than Monday's. That's a low bar. How about a linked list? a sorted linked list. Can you do binary search? No, you cannot do binary search in this case. It is big O of n to find. Ok, this is the moment where oh boy, this is for find and this is for shift. Ugh, how about removeMin? How about removeMin? Are these correct? They constant in both cases? Is this correct? Could this have been correct if I put those differently? So, ok, I should have done 21, 13,8,5,3, and then it would be constant time. Because we always remove frome the end of the chunk of the data. Ok, how about for a singly linked list? Does it take constant time to remove the minimum? Yes, if you keep the minimum where? At the head of the list, right? What if you kept the minimum at the tail pointer? So, I am going to keep the minimum here, and I have a tail pointer. What do you think? Removing that guy. No, because I can get to it in constant time, but resetting this tail pointer while the traversal of the structure. OK, everybody good? Ok, so, take a look at this messy table, and it looks like there is trade-off going on, right? So, we got constant time, for on of the functions, and linear time for the other function. What would be better than this? What would be better? Log(n)? Log(n) would better especially if we were able to replace the linear time functions with Log(n). Well, I am not going to tell you how good it gets, instead, I am going to switch gears, so that's a reasonable goal. The question is, whether we can do log(n) here and constant time here. Just how good can we do using a different structure. Ok? Now. I want to leave this one hanging, OK?  Because I want to show you something completely new. This will be more fun for you. If you focus here instead of your paper. Ok, don't look, I know you want to look, right? but don't. Ok? Alright. So, here is a new structure, what I want you to do, is tell me, everything you can about it. Tell me everything you can about it. Everything you might be think interesting, everything you think characterize it.  
