Here's our next little exercise. I want you to ask me to remove something from the bag. Somebody raise their hand and ask me to remove something from the bag. Somebody raise their hand, we're going to have a little conversation, okay, you're right here, we're going to have this conversation, they're all watching. okay, you ready? do you want to stand up? No, you don't have to; kidding. Ok, so say "would you please remove four?". You say that. (Can you remove four?) Um, no in fact I'm not going to remove four. You don't get to tell me what to remove, okay? (laugh) (you set him up) I set him up. I totally set him up. Are you okay with that? Yeah. Okay. This is so stupid it's funny right? like ARGH! Ok, so the deal is that remove in this context is special purpose. All you can say is " I'd like you to remove something" I will decide what I'll remove, thank you very much. So go ahead, here I'll give you another change. Ask me to remove something. Ok, I will I'd be glad to do so. I'm going to remove -42.0. Okay? Anybody want to ask me to remove something? Ask me to remove something, c'mon I'm not doing all the work here. Thank you! Alright, I will remove 2.0. Okay? Anybody think they know what I'm going to remove next? Pi is right, ok, next, 4.0, that's right, and then 1000. Good. So what's going on here? What's a better name for remove? Remove smallest, right? I'm going to call it removeMin(), okay. These two functions. These two functions are the functionality of Abstract Data Type Priority Queue. Our choice of min here is arbitrary, we could have done removeMax() equivalently and think you know what order I would have happened to have removed them if when instead our priority queue was a max-centric priority queue. Sill a priority queue, you just have to sort of further specify whether it gives you the minimum value or the maximum value. For our context, we use a minimum value because a priority queue is going to be a tool for us to use particularly in graph algorithms. So this data type, this abstract data type that we're gonna implement in a minute, happens to be more useful to us if we use the minimum version of it . Ok, so we also typically implement a getSize() function so that a client can tell how many elements there are in the priority queue at any time, or the bag. ok, any questions about this so far? So what you learned is the classic functionality of the abstract data type and the fact that it requires comparable keys. Any questions? Ya good? okay. So let's go for some implementations, okay, some options for implementation. So the first thing, I'm going to go pretty fast through all of this because I think you know it already. A few moments of contemplation will get you to the same answers that I did. But here's the thing. I haven't looked at this slide in maybe a year, and I'm thinking I might have deliberately put some mistakes here. So let's go through them quickly and determine (it's not really true that I haven't looked at them in a year, in fact I have all  of my notes right here but I'm going to make that the narrative okay? Um, let's go through them very quickly to see if these function running times are accurate in the context of some obvious choices for implementing a priority queue. Here are the two functions we are responsible for providing and here are a couple of implementations: An unsorted version of an array and an unsorted version of a list. Boy! Power Point doesn't like to give me my little black lines apparently.  