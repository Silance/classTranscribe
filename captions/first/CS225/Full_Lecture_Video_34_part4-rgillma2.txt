Due date so do you next, do next, the thing that is do next gets your attention. It's some strange weighted average, right? Of do next, worth most, you know. It's like most the one that makes you happiest, right? Well that'll be us, you know? Alright, so, this function that determines the keys in the ordering in the priority queue can be lots of different things. Also, when we talk about graph algorithms, we'll be using a priority queue to order the order -- to plan the order in which we visit edges of a graph. So this is graph search. Graph algorithms in general tend to have a lot of priority queues and that's foreshadowing. That's where are we going with this? Why did we talk about it at all? Alright, so any questions about that? I love this. I love that it's a rich conversation that has many different levels and yet somehow inherently safe because it's just computer science and not, like, philosophy. Alright, okay, so is that thing a heap? Is it? If I'm keying on the characters, the alphabetic order of the characters. No, and what's your evidence? The U is greater than L and D, right? Okay, alright, so I believe it. That that one is not a heap. Now what I wanna know is what would be an algorithm for making that into a heap? What could you do? I'm giving you the data, you can assume basically that your data is laid out in an array. Here is an array with all your data, make it into a heap. What are you gonna do? Yeah? Oh, why not sort it, right? You can use mergeSort perfectly fine, perfectly reasonable idea. But we can do better. What does it mean to do better? What's the running time for merge sort? Big O of? Whoa, okay, you guys gotta write this down and put it on your mirror, okay? Even if you don't know the proof of this, it should just roll right off. You can be talking about stuff you don't know but this one should roll off, okay? The running time of merge, watch me get it wrong here, the running of mergeSort, worst case, is nLogn. Okay? So you're guaranteed nLogn for mergeSort. It's a great sort because it's very hard to do in lace, especially if you're doing it in an array. You actually did it in place for MP3 I think, but your memory was all over the place. Alright, let's see. So, we can sort it, that would work. What else could we do? Yeah? Oh, use heapify! How would you use heapify? What would you do? What is, how would you use heapify here? How would you use heapify? Oh heapifyDown at the root? It turns out that doesn't work. Yeah? Very good, very good. So the other thing you can do is pretend like this is just data that happens to be sitting in memory and do repeated insertion into the structure. So first we've got an empty heap, and we're gonna add B to it. Okay? Well, there we did heapifyUp from here, fine, done. Then we're gonna add U to it and now we can look at this part and say okay that's a good heap. Then we can add I to it and that's a heap. And then we add L to it and what happens? No, it's fine, this is fine. You have to swap, right? But you're inserting so you get heapifyUp for free so L and U should swap, okay. And now that's a heap. Now everything up to here is heap. Okay, so do you see how this would play out in the end? One at a time, you're just gonna add each one of these. It's like however many vertices there are here inserts into the structure. Okay, do you like that?