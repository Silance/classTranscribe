okay so so its working, alright, proof of concept, now I'm going to plug it in because i like it, okay , alright, now I'm going to do 40 again, sorry, you know, delete, boink, muted anyways, who cares, oh, okay, so that was fine, and then I'm going to insert, I'm going to make it look like it was before, oh no, don't mess with me. 76. Insert, boink, boink, boink, boink, and oh okay, and now we are going to be inserting 85. didn't expect that part to take 5 minute. Okay ready? ready? are you sure you are ready? they do it a lot faster than we do. lets try, alright, so now what i want is something that you can insert, lets take 85 out, okay? Sorry I'm keeping it in for one time. Okay. Deleting 85. Oh its not working. Ill save you. Nothing is out of bounce, now I want to know some key that will inserted will result in right rotation. 62 will do it. Anything bigger than 36 or less than 75 right? anything inside 75's left subtree will result in a right subtree, is that true? Yes. And anything in 75's left subtree can contain keys between 35 and 75 so somebody raise their hand, you get to speak here. Yea what number do you want? 45, okay. 45 and inserting, okay, boink , boink, boink, boink. Oh, thats not out of balance, oh. Okay right rotation. Okay any question about that? What happens when I insert 17? Nothing special right? Finding the spot for 17 and checking to make sure that everything is okay on the way up. Yea Mike? Oh, uhm, so, going up is sort of like yelling out a value after you processed the rest of the tree in a post order traversal, okay so I'm going to do this post order after the recursive call is made. Okay? Does that make sense? And when you look at the code, ill be sure to point it out, so all of this evaluation assumes that the insert actually happens. Okay I want now a key that will result in a double right rotation, in a right rotation, but a double one. A double right rotation, I believe that there is only one key that will result in a double right rotation.  It's a power of 2. 