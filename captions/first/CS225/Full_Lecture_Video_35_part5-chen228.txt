You want to go, there it is! Right? It's right there. I see it. What I really mean by find(4) in this context is, tell me what its equivalence class is. Tell me some representative of the set in which it resides. So this is very different than find from the past, right? In the past when we did find, we pointed right to it, or return its key. We're gonna do something different here. In this case, you are going to return, you're gonna return a representative from the set containing 0, 1, 4 and 8, and anyone of them is fine. Wow, what? Okay. Okay? Anyone of them is fine. Feels very ill defined at this moment. What must be true, I'll answer your question in just a minute. What must be true, is if two things are in the same set, they must return the same representative. So I don't care which one of these you use to represent this set. But I want to be sure of, is if two things are in the same set, it will tell you. You will get a true because the representative is the same. Okay, was there a question? Did you have a question? Yeah. I can return 4, yeah. Yeah, it does, doesn't it. But when when I do a find(8), then I can't return 8, okay? So sure I can return 4 but that means I am gonna know when I know where 8 is, then its representative is 4. Mike? Yes. Okay, so the question is what if you have a 12 and it belongs to the blue and green. It can not. 12 can not be an element in two different equivalence classes. Equivalence classes partition set. There is no intersection, the intersection between every pair of set are disjoint, are empty. Okay, is that clear? Alright, so good question, I am glad you ask it. But that can not be, okay? Alright, fine. Here is an example of typical use of this structure. If it's not the case that 7 and 2 are in the same set. If it's not, if 7 and 2 are in different sets, then take the union of the sets represented by the find(7), and the find(2). So take the union of these two sets. Alright, so find(7) is going to essentially give us some representative of that set. Find(2) is going to give us some representative of that set. They can not be the same because these are disjoint sets. And so we are going to, as a result, the "then" is going to be to take the union of these things. Now we are going to assume that find, I am sorry, the union operates on representatives. So assume the union operates on reps. Representative. Any question about that. Alright, fine. Here is little bit of a more formal description of the abstract data type. Each set has a rep, so we are going to maintain a collection of disjoint sets. In this example here, we have three of them. We have three of them, obviously. Each set has some representative member, we are not gonna to try to prescribe who that is. We are gonna let that, just kind of flow out of the application somehow, the implementation somehow. And we need to be able to support the following functions. We are gonna need to make a set, from a particular key. So this is a key. We are going to need to be able to take the union of two things, where these things are representatives. Okay? Sometimes you don't have to, sometimes you can just. Well, we'll talk about that later. And then find will return a representative.