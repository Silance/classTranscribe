Ohhh... okay. So, notice when you are building these trees, that you are making a sequence of left/right decisions. You are making a sequence of left right decisions. The first thing is always going to be the root, and then you are going to decide whether the tree is going to to have, be, uh whether the next data element is going to be something smaller, in which case you go to the left, or something larger, in which case you go to the right. So, simply, each one of these trees is simply a, uh, sequence of decisions of whether you go left or right. To reinforce that, I can write down right, left , left, right, right, right , left, I can write down one these, and it prescribes a tree. How many choices are there? Well, there are n-1 choices. There is one for each edge here. There are n data elements, There are n-1 edges, and there is a choice of right or left for each of those. And so in total, it's two to the two. It's two times two times two times two times two, n-1 times. Okay? Any question about that? Yeah? Because, uhm, if I have...here's how I really do it, right? For data equals two, if n equals two, how many trees are there? How many trees are there for n equals two. Two, right? Okay. So, this is how I really do it, I go oh, gosh, if we're two to the n that would be four Hmm.. it must be n minus one. And then I check that out. No, I'm serious. Simplify your problems! Always simplify your problems. Okay. So, two to the n minus one, Also recognize that the data is the number of nodes but the decisions for where the tree goes are edges and there are one fewer edge . Theres one , there is one fewer edge than, yes. My...Oh yeah this i s tree...yes, yes, this is definitely a tree. No cycles here. This is a ...uh..what is it? Rooted ...heh...connected acyclic graph that is rooted and ordered in binary, oaky? Did you have another comment? Okay, alright, anything else, here, about this. I didn't know, I didn't plan..alright, is this a big number or a little number. A lot. This is a lot of bad trees. Which means that, it means that we really can't count on the order in which the data comes at us, to use as a criterion for building these structures,right ? If we just build the structures using this strategy of: okay ill just insert into it whenever you give me data, it's possible it's possible that, you know, we're going to get a bad tree. And that height, that, uh, algorithm, will take this, the algorithm insert remove and find will take us a long time because we have this tall tree. Alright, well...uhhh...we should quantify this. We should quantify this. Alright. So, here is what we're going to do. We are not happy with big O of h for running time. Because, people who listen to, argue about the efficacy of your algorithm, always want to hear about their running times in terms of the amount of data your structure contains. So, the analysis, oops, the...