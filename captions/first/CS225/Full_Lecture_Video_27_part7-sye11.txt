Okay first let's make sure that this sort of does the things that we thought it should do from the steps from the previous slides. So notice that this is, well, if I ask you to describe what this is what would you say? Base case. Good. That's the base case of the recursion. It's simply creating the node. The reason this works to just set the t to equal to the tree node is because we have t passed by reference in the parameter. 
All right. Any question about that? So that creates the yellow node. Okay, and then the rest of this, if you hide this conditional, it looks just like a recursively inserting into a binary search tree. And in fact, that's what happens first. So in each of these cases the first thing that happens is the recursive call.  So everything follows the recursive call. So here's inserting in the proper place from the previous slide. Here's check for imbalance. Okay, here's insert to the proper place. Here's check for imbalance. Oh there's an imbalance. Do the right kind of rotation so this is diagnosing  what kind of rotation you need. And after all of that is done, before you move up, before you pass control out of the calling function, you recompute the height, you may have to look at your own paper for that. You update the height of the parameter node. Okay any question about that? [...] what has to happen or how it's happening when we do things after the insert or working up the tree? Okay any other questions about this? I guess we should filling the blanks. 
So what goes in this blank? It's the easiest one. What's that one? Okay, so it is out of balance and longer on the right. So we need a left rotation. This one is a right left because it has to be some kind of a left rotation. And then up to the top  everything looks symmetric. So I'm just gonna write this code without thinking about it. And hope I can catch the problems in the testing. Okay, any question about it? So you know this is the kind of code I would write this part of some thought and then just do some substitution there. I don't like this code and particularly don't like the fact that this and that are kind of the same. So I might reflect it a little bit and make some helper functions. But it's a little tough. And I'm not really sure you have to pass a flag parameter that help you diagnose right or left. I'm not sure how I would refect this. I know this is quite readable here. 
Because you know height is always going to be the maximum heights of the two children which I have updated right plus one. No, this parenthesis closes this one. And notice here I've got a helper function that's gonna deal with the case that one of them is null because I don't wanna deal with that here. Same thing true here. Balance factor is gonna deal with the case where t right is null or left is null. All right, any other questions about this? 