Ok. Now, here's what it means. It means your hash function basically spreads your data out, over the table. It minimizes the likelihood of collisions, of two things mapping to the same small index. Ok? Now let me write that out mathematically. If i is not equal to j, that is you pass in two different key values, two different key values, then the probability that, em, h of ... Well, it doesn't matter which where I write it. h(j) is the same as h(i). Is... Oh it would be great to say it 0, right? Oh I wish we could say it 0, but it isn't probable. It probably isn't. There's a bijection. Em what you want to be able to say is that it's one less than or equal to 1 over the table size, which means this. Suppose that i maps to this cell. Ok, so i came along and h(i) is here. All we are saying is that the probability that j is no more likely to be here than anywhere else. It's equally likely to be spread out over the table. And the nice thing is, what that means 1 minus 1 over this, that there won't be a collision. Okay. And there all kinds of probable listed results here that mean you can say with high probability the table behaves well over a sequence of, e, a sequence of hashes. Okay? Alright, any question about that? Okay. It is the case that mathematicians spend most their time, em, under various constraint, focusing on this particular aspect of it. Right. This one kind of dahh. This one, you know, you can get a good, a good one here. It took long time to do, but em, this is the most, this is the most interesting aspect mathematically. Okay, I want to talk about the consequence of breaking each of these criteria. What it would mean for a hash function. So let's talk about a bad hash function. Bad hash, good hash functions have a this and this and this. So a bad hash function would negate that conjunction, right? Would say that means either this is bad or this is bad or this is bad. What would it mean for this one to be bad, to be violated? What it mean in terms of the client code? Yeah? Right, right. The dictionary functions would not be constant time. We already have, we already have dictionary implementations that get us algorithmic time, they are? Will this get us algorithmic time for dictionary functions? AVL trees. That's right. We already have that. So, anything worse than constant time here. You know, we're kinda happy with. So, we're only willing to give that hash function constant time to execute. Okay. What would it mean if this one is violated? If the hash function didn't do this. Yeah? Yeah! Think about this. Think about it. You're gonna insert some thing into a place in your, in your table, right? in your array. If you want it back, or you wanna look to see if it's there... If your hash function doesn't send you back to that spot, it sends you some place else. You are lost, right? You're lost. So, hash functions have to be deterministic or it won't be functional. Again, it could be a case that you could search through the whole thing, but that's no better than we already have. Alright, emm... Let's see. And then finally, what's the consequence of something not satisfying the "suha", not spreading the data out over the table? There is a number of collisions to handle. In fact, so many might be the case that all of your keys map to the same spot. Now it would be bad. That's like putting everything into a linked list, essentially, perhaps. Alright, we'll just talk about that in just a minute.  Okay, so, emm, not satisfying this means lots of collisions. Ok, I wanna ta... Yeah, Polly? 