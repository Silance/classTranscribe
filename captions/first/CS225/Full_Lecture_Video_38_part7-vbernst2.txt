Okay, now...Functions on such an abstract data type are many, There are many many. Uh, at a minimum we have to be able to insert vertices and edges, remove vertices and edges. It's very common to need the set of incident edges given a vertex. So this function would return to you, would return a set of incident edges, or an iterator over them, for example. OK? But the way you should think about this function is as returning a set of incident edges. OK? Our adjacent is a boolean that tells whether not v1 v2 is an edge in the class, see just test, and then finally these two we'll talk about them more...They are only for directed graphs. For now we're going to assume our graphs are not directed, they are undirected. Alright, any questions so far? Here's how we're going to do this. We're going to look at three different implementations and we're going to compare a few functions across all of them. Now, we're not going to look at all of the functions on the previous page, because we would fall asleep. These functions are adequate for getting at all of the issues. OK? Alright, implementation one. It's called an edge list, and basically it works like this. It is a structure for this, a structure for this, a structure for this, and we're not going to specify any particular reflection of the connectivity. OK? So we're just going to have maybe it's a hash table, constant time access to the vertices. Constant time access to the edges, and that's our structure. That's it. OK? Now, what does it look like? What does it, what does the implementation look like? The data associated with each of these things. Well the vertices it's just a list of vertices. Maybe you associate a weight with them, or a time they were created, or any other data that you want. But for now they are just a set, it's just a set of vertices, or a map of vertices. The edges though are more interesting. Edge A, for example, will contain data that reflects it's endpoints. We've got u and v here. B has v and w. C has u and w. And D has w and z. We're going to engineer everything so that u v is the same as v u. So it doesn't matter which order I put those in. Alright, any question about that? Yes? [gibberish] So that's a more complex, that is, that actually does...So what you're suggesting, so the suggestion on the floor is how can this be a good idea? Wouldn't it be a better idea to list for each vertex it's set of incident edges, and yes, that would be a better implementation. But we're not going to do it  yet, we're going to be stupid first, because that's what we do around here. OK? We do things naively first, and then we'll move into complexity. OK, so I want to know how long does it take to insert a new vertex into this structure? There, I did it. How long does it take to add a new vertex into this structure? Constant time, very good. OK, this is adding into either the array or map. You have to be able to assume it's constant time. Fine. How about removing a vertex? Oh, and I'll use this notation. The size of the vertex set is n, the size of the edge set is m. So there are n of these and m of those. Ok, what does it mean to remove a vertex? Here, there I removed v and I have to remove all of it's incident edges. So removing a vertex really means remove the vertex and incident edges. So how long does that take? Big O of m is correct. Because we have to search this structure, right? Oh, there's a v, there's a v, and no more v's. We have to search that structure.