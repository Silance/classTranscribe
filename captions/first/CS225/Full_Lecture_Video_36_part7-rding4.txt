If we do find a 4, we recursively walk all the way up the tree. Right? But this is recursive process, which means after it's complete, we have to fall out of the recursion and after it's complete, we know about ten. So in a post-order way, we are gonna do the following: when we first look at 4, we are going to do a find on 4's parent, and after that is successful, we are going to connect 4 to that parent. Then going up the tree, there will be a find on 2 after which we are gonna connect 2 to that root. Then, there will be a find on 7 after which we are gonna connect 7 to the result, and then there will be a find on 9, after which we are gonna connect 9 to the root. Now, this is what that looks like after that process, you could probably draw it too, I'm gonna just redraw the whole thing with the blue arrow taking into account the correct arrows. So ten still has 9 as a child, and 11 as a child. But  now it also has 7 and 2 and 4, and 1 points to 9, and 8 points to 7, and 3 points to 2, and 5 and 6 point to 4, and nothing points 11. So we took this tree whose height was one, two, three, four, five... whose height was five and by doing a find on it, change it to have height two. Any question about that? Alright what do you think the code looks like? So this is the old code- this is the old unionBySize. We are kind of ignoring it right now. This is the new find except that is the old find with just a few spaces thrown in. What goes in those spaces? Remember that what we are doing is changing the parent of the current node to be the result of the find. Let's take that sentence and put it in code. we are going to ...oh here is the result to the find. We are going to change the current parent, current node's parent to be that. That's it. So this implements path compression. You guys are quiet today. Any question about it?