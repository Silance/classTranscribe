Yes, exactly, exactly, yeah remember this is a 1-D's array. Like that starting the root at one gain does the efficiency of being able to use 2 times index as left child, that's in last lecture.
All right, any other question about,oh , I know , so this mean child actually when I wrote this code, I think I remember spending very most time debugging this part of the code. And the reason for that is because notice that I don't deal with the case at all that has only one child .deal with that, that one strange incidens ,case in the complete tree where there actually aren't even two children.  I don't deal with that here at all . I only  deal with the () function , so this function mean child  actually hides this test to see there are even two children and in the either case if there is only one child returns it. If the two returns the minimum of the two. OK,  alright and because of that uglyness.  I () it to the helper function.  Alright , any other question about this code?  What questions do you think I'm gonna ask you ? As I show you some code, what do you think I'm gonna ask you?  Exactly, very good , what's the running time of this? As the algorithm we completely understand how it works. What's the running time of this thing of removing something from a heap?      Log n and please justify that .  The running time is O(log(n)) , good! because that's the height of complete tree. Ok, any question about that?  Ok, I love this discussion ,because oops, woo. I love this discussion ,because our original goal here was to implement priority queues.  Our goal is to implement priority queues.  With the assumption of that kind of abstract data types would somehow be useful to us. OK , and we are proposed to hold to implementations and this last one will compare more carefully to the other ones a little bit latter. This  last one is a structure as beautiful in its own ride called a heap. But a heap really has a discussion about the implementing of this implementation, right ?  And in the end, the discussion about the heap was the implement of the pointers and as a array decided should be clever use of an array and this notion  that abstract data type can actually lead to this sorting of unfolding discussion of implementation in decreasing structure more specificity  is fascinating  to me. Moreover , there are tons of structures and algorithms for which priority queues are in extremely important , uhh, element , so for example,  the event queue in every single video game ever exists, so this is a event queue uses a priority queue which one needs to connect it is priorities by time . Even if all the events create at the same time ,it can be throwened  into priority queue , so the next one would respect to time can be handled. Umm. another application I bet you won't be surprised that the original system that allocated the memory ,dynamic memory, use priority queues ,right? Implemented as a heap , I don't know the priority queue level , so memory allocation where in this incidence , the size of the block of the memory to be used typically was in very early implementation when they were just doing things . sort of .. Without of a lot of resources,when they just developing this algorithm that memory allocation was based on how much memory it blocked , a block of memory it had , so has the size of block , so the priority was the size of block there of memory. Another one is your to-do list,  what your key to your to-do list.
