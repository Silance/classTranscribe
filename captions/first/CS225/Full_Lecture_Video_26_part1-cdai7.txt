On a Tree, and this one is a characterization of a tree that uses that measurement. OK, so the vocabulary is the same, but there is a subtle difference in their application. So we say that a tree is height balanced if its an empty tree. An empty tree is height balanced. Um, or, if it is not empty, then you know the recursive, the recursive nature of this definition says whatever is true for the entire tree must be true of the sub-trees, and I think what you wanted me to write here was b equal zero, but I didn't, I wrote the absolute value of b is less than or equal to one. So rather than demanding, rather than demanding that a binary search tree be perfectly balanced, in all it's sub-trees, we allow a little wish-washy-ness. We allow a little bit of imbalance, and the question is whether that is a big sacrifice or whether it kinda gets us what we want. Uh any questions about that before we go on? OK. so is the tree on the left, ignore the little trees, is the tree on the left height balanced? OK, I'll say no, it is not. It is not height balanced. Now, I want you to find me the sub-tree that is not  balanced. The sub-tree rooted at ... 51, very good. So take a look at 51, at that node. and what you observe is that, you know, the height of the left sub-tree is zero and the height of the right sub-tree is two. you know, I don't ever really think about the height of those trees, i kinda eyeball it and look at the difference in the levels, Oh look, there is a sub-tree where the left and the right are different by two. So, hence, this tree is not height balanced, OK? alright, Uh, lets see. So what we're going to do, what we're going to do moving forward is take our earlier observation, take our earlier observation that we prefer mountains to sticks, and we're going to view the change, we're going to view it as an operation on the tree, to go from a piece of the tree that looks like this, to a piece of the tree that looks like this. OK? and the piece of a tree that looks like this is going to be based on the observation that this example tree is out of balance. and by doing some little operation on the very same data, we create a tree that is very nicely balanced, thank you very much. So now lets apply that thought, that impression to this tree, where is the stick in this tree, where is the stick that we might want to change, where is the string of uh nodes all of which play into might be. what is an imbalance. Why there it is, ok, so starting at the node that is balance, the lowest node in the tree that is out of balance, because it is possible that was another node out of balance,  but starting at the lowest node in the tree that is out of balance, we are going to observe that anything that looks like this, if we apply this magic operation and just change that portion of the tree, we could actually change the structure of the tree in a way that reduced the height, OK, and we're going to talk about how to do that just in a second. Alright, any questions about that? No there are no technical details, by the end of the next slide, you will know how to do all the pointer assignments necessary in a pointer based tree to make that happen, so if it all feels technically a little mysterious right now, that's perfectly fine. Ok, i have another question for you, um how would we assess, how would we find fifty one and determine that it was out of balance? what would be an algorithm, just kinda a loose description of an algorithm, to figure out whether or not fifty one is out of balance? Ew that's a hard problem right? 