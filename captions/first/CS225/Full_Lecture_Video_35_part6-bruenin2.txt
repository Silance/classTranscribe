just like we said before. Okay, so, I thought about this for a minute and I came up with this idea for a data structure to support this abstract data type(ADT). I set up this example into an array, where every array entry is an identifier for one of the elements in the set. Now, that's perfectly reasonable to do because we can either make this an associative array or we can keep a map of each of these identifiers to a richer key type. So it's pretty reasonable, actually, to just say "I'll just use the indices as element identifiers". The indices are element identifiers, and look! 0 and 1 and 4 have 0 as their data, indicating that they all belong to 0's set. In this case, 0 is the representative. Any questions? Good? It's okay, and you can see 2 and 7, and 3, 5, and 6 - perfectly fine. So what I wanna know from you is what is the find() algorithm? How do I get a representative of the set containing 5? How fast can you give it to me? Well, I've got it stored here - that's true. But I can't be sure, if I used those, if 3 and 5 have the same representative. If I ask for find(5), I'm gonna return 3. This takes constant time(O(1)), that's right. So, if I get things set up like this, I can implement find() in constant time. I can do this because find(5) will return 3 - it's just an array access. The top row contains the indices, and the bottom row contains the representatives. Any question about that? It seems to work pretty great, right? How about if I take a union....ahhhhhh, I don't know. Let's take the union of those two. This will be the union of find(1) and find(2). Okay. Because I want to take unions of representatives - cleaner that way. Now, how do I do this? What will my algorithm be? ... Yeah! I will change the representatives of the sets to be the same. They must have the same representative. Which one do I change it to? Should I change the representative to 0 or 2? Doesn't matter, but I need a way of determining which one to change. Hey, should I change you, should I change you, should I change you? Yeah, probably should. Traverse through the array, finding which ones you need to change. I can't think of another way of knowing what elements are in a particular set without just going through and looking. So union in this case is O(n). Groan! That's a groan. Let's see if we can do better.