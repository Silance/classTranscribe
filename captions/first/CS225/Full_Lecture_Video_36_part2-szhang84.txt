Very good! So, in the table, so remember that roots are indicated by negative numbers. And in the table 6 is supposed be a root, not 3. In the table it says 6 is 3's parent. So, that is my intentional bug. Anybody else find something different ? some other error? So notice that these are not ordered trees in any sense. So it didn't matter where I draw the 2 and 9 here relative to one and another. There is no notion of a left child and a right child or a middle child. So this tree is ordered, it is not necessarily binary though. This example happens to not to have any non binary nodes. It is direct, that is the key part. Let's take the union just to remind ourselves how to take union both in the context in the model and in the context of its representation in memory. So I want to take union between these two sets and do something that makes all of this in the same tree. So I got these 2 trees what should I do? Yeah, make one of the root point to the other. Now, should I do this or should I do this? OK you think 5 should point to 7. Now what I want you get from that little exchange is that there was a choice to be made. And for now I am gonna make a arbitrary choice. I am just gonna have the one on the left point to the one the right okay? but you should recognize that was arbitrary. OK finely, if I say something like the union of two with 7, what i really mean is the union of the set containing 2 with the set containing 7. So I need to call find in order to get the appropriate representative of that set. Ok any questions? All right so, and the reason that I bring it up here is because when I talk about these function and when we discuss running time of these fictions, we want to find to be decoupled from union. When you implement these things in mp7, you are gonna throw a find inside because you do not want to have to demand the client do this every time. So, there will be a slightly different specification for the union function in the mp than there is here. But I want to decouple them, because I want to be able to talk about running times separately. All right any question. So let's write some codes. Function find is going to take a key or a element identifier and it is going to return the root of the up tree, as a representative. Now, look at this code, it is really cool! If the value in the array at i is less than 0, it means i is a root, that is what we agreed on. In which case, we are gonna return i, otherwise, we are going to walk one step of the tree. Ok, so we are gonna find on i's parent.