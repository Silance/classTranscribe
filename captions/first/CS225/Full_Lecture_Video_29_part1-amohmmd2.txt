4 to 8 gig? Is that about it? Okay, assume you can only use half of that. Or at most, assume you can use a fourth of that for, uh, computation on any one given program. That's probably even an overestimate. And, and you realize that any data set that's larger than, you know, a couple gig really merits some other storage, okay? Um, in, yeah, I'm not going to analyze driving records. That's, you know, whatever. That's kind of a fake application I think. I don't know, maybe it isn't, I never really looked into it. So, not going to look at this, okay? The point is, the point of it is this: if you can't fit an entire AVL tree into this immediately accessible piece of memory, this RAM, this heap memory which is part of RAM, then your only alternative is to store it someplace else. Now, I'm going to talk about that someplace else as if it is a hard drive, okay? But, all of the conversation applies anyway. So here's where we were last time. We observed that if we have some balanced structure, and this one wasn't balanced so I better make it balanced, if we have a balanced structure that we think is a reasonable way of accessing our data, but our data isn't close to us, that is, that balanced structure doesn't fit in memory that is fast, then, if we're going to do this sort of search for 38, 28 may be out in some place where the communication cost is high, whether it's a disk or the cloud or whatever, okay? Now, the other piece of- is that clear? Is that clear enough? This is high communication cost. Your pen is different than mine, it's kind of cool. I didn't know a pen was like a personal piece of electronics... a stylus. Okay. That says high communication... in the font that this pen chooses to write in. Okay, but what is also true about all of this sort of remote data is that you don't get just one piece of data at a time. You get a block of data. So even if you're only looking for key 38 on the moon, when you go to the moon and come back, you come back with a whole bunch of stuff. It's just the unit of transfer that happens either via remote communication or via communication with your hard drive or your solid state drive. Okay? So, here's the thing. You want to make sure that piece of data that you get is relevant to your search. Relevant to your application. Okay? Alright, and that's kind of where we were. So we're gonna define this structure called a b-tree, and into a b-tree, into a b-tree node, we're gonna throw, not one key, but a bunch of keys. So you can imagine that this whole thing is a b-tree node. And it corresponds to some linear function. It is some fraction of a transfer block from your disk, from remote storage. So this is some fraction of a block in remote storage. And the reason I say that it's some fraction, like a fourth or a third, the reason I say it's some fraction is because when you get the block, you need some other information, just like when you get a binary search tree node, you also get pointers to children. In this case you're gonna get your collection of keys together with some other redirection. Okay? Together with some other information. Okay, main goal. We want to minimize the number of reads from disk or any other remote storage. Okay? Alright. I wanna show you how these things work before we do a formal description, and the way I'm gonna show you how they work is by hopefully pushing on this link. Oh, it worked! (joyous exclamation). Oh. Gnarley Trees. That's new. What am I doing? Okay. Alright. This is my... okay. That's not the one I want. I want that person, but I want the big, okay? And we just hope it exists at this point. Union find ordered dictionaries. I don't know. Ack. 