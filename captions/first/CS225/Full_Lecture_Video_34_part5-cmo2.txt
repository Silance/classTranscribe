Yeah, Nathan what are you thinking? It is also n log n, good observation. Yeah this is n log n. Now let's talk about why, okay? Let's talk about why. This you're affectedly calling heapify up, yes? And you're going to call it on every single piece of data, okay? Look at all of these leaves down here for they're going have to make a trip. Potentially, all the way up the tree right? Each one of these, so that's a lot. This is like effetely have data, could be have a data. And they're going to go all the way up the tree. So that is, big O of n log n because it's n/2 things or big O of n things each of which go log n of the tree okay? Alright that's not satisfy, so why are we having this conversation if the best you can do is n log n? okay, so......it isn't the best you can do. what is better? what's better than n log n? Big O of n that's right. What are we going for is the ability to take a an array of data like this and create a heap out of it in linear time. Alright, so, I have a way of uh.. kind of giving you a hint about this. Uh, I need a volunteer. Any volunteer to come to the front of the room? This make this thing up on a Friday. Hurry up, now, yes you know you want to do it. Raise your hand if you want to do it you are kind of afraid to. Raise your hand if you're afraid to raise your hand that you're afraid. Okay, you're up. Okay, and what I want you to do is point not to, well, you can choose whether point to the n-tree in the array or a vertex in the heap that is already a heap. It's already a heap. A root of some subtree which is already a heap. D, okay, that's lucky. Alright, D is already a heap right? Okay, fine uh point to another one. That's already a heap. okay good H is already a heap. Point to another one. This is a lot of pressure isn't it? I will giving you hint, there aren't any more higher up the tree. Okay, very good, no no no, higher up of the tree. You're not done! There are no more higher up of the tree. Oh! look those, all of those are already heaps. Okay good, thank you. Oh yes, they're already heaps. Do you see that? Yes, thank you very much for doing that. Do you see they're already heaps? And they're guarantee  to be heaps right? Where as D is just lucky and H is just lucky. So the leaves are already heaps. Okay? Alright, so stop me when I running to a node that is no longer heap. You're heap, you're heap, you're heap,you're heap , you're heap, this one is already a heap right? These are already heaps, yeah? How about L? Is L already....thank you. How can I fix it? How can I make it so that this node this vertex right here might hold different key, but it is the root of something that is already a heap. Do heapify......down. Let's right, heapify down on L. Okay? Heapify down on L. What happens? A comes up. Okay fine, then we have to do it here heapify down on I. Then we have to do it here heapify down on U. And then eventually heapify down on B. Okay? Any question about that? Is this n log n? Feels like it could be right?  Feels like it could be because B is trip to the bottom could go all the way down, B could go all the way, this could've been a Z sitting here right? B could go all the way down to the bottom. The difference in this case is, only one vertex that has to go all the way to the bottom, instead of all the leaves have to come up in the other instance. So, let's see if this actually does our linear running time. Before we do that, here are the three things, here are the three alternative. That was going to planing on my part, there is answers on the other side. Okay, sort the array big O of n log n okay. Sort the array, and then you can argue. uh oh, No, don't say the class is over. No.....no no no. It's not that much Friday. 