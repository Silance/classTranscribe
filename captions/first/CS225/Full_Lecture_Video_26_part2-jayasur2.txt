What? Who's talking to me? Is that you? Okay, yes, what's your suggestion? Thank you for.. Ahh, okay so you want to write a recursive function to do this, right? Okay, so write a recursive function that... write a recursive function that checks to see if these are out of balance, right? So, the code that can check for balance is, you know, its almost gonna look like a traversal. You can write the recursive code that says "Okay, I'm going to look and make sure my left subtree is out of balance, or balanced, and my right subtree is balanced, and what else are you gonna check? Because, look, for 51, the left subtree is balanced and the right subtree is balanced. So what else are you going to check? What else are you gonna check? If you're sitting at 51 and you've made a recursive call that came back, oh yeah, your left subtree - perfectly balanced, no problem. Your right subtree - balanced, no problem. So then what are you gonna do? yeah? check if its balanced at that node - what information do you need to do that? Yes, very good, you need the height this subtree and the height of this subtree, okay? So, here's what we're gonna do. We're going to augment the information stored in every node with the height of that node and we're going to maintain that as we do insertions into the structure. Okay, so [gibberish] a little asterisk about what we're going to do by way of foreshadowing is... it would be helpful to store height in each node. We'll talk about exactly how to do that in a minute, this is all intuition. Okay, so lets do some mechanics here. I wanna change this, I don't like this tree very much. I wanna change the structure of it. Notice that the whole tree is out of balance, right? 50, is the root of the tree that is out of balance. Yes? Is that true? Did I eyeball that correctly? Okay, but so is 80. So I'm actually going to focus the code that we're going to write together, the algorithm that we're going to employ is going to focus on the lowest node in the tree that's out of balance. Okay? So here's what I'm gonna do. I'm going to take this stick and change it into a mountain. So that mean, for that subtree I'm going to change 90, I'm going to change that subtree to 90, 80 and 99. Okay and now we have to hook things back together. Now where do things go? I don't know for sure but here are my observations. I have one, two, three, four places I can hook subtrees into the original tree. And I have one, two, three, four places I can hook subtrees in to the new structure. Thats good, if that were different we'd have a problem. So four places in the old structure, four places in the new structure and if you notice in the old structure we can  make the following observation. Everything in this subtree labeled A here is going to be less than everything in this subtree, which we're labelling B, because of the binary search tree property, which is less than everything in this subtree, which is less than everything in this subtree. And furthermore the relationships to their parent nodes are... are correspond to... and that will be true over here. And furthermore, the relationship to the parent nodes will be preserved if we only put A and B and C and D, hook them up right here. Okay so I'm gonna do this, I'm gonna put A here, whatever is in A I'm gonna put there, i'm gonna put B here, I'm gonna put C here, and I'm gonna put D here. Okay? Alright, so what is that? I'll do that in a different color so its easier to see. Alright, so 80's left looks like this. B will now be 80's right so that looks like this. C will now be 99's left and D is empty so there's nothing to do. Okay? So notice that this, actually, for that subtree, for the subtree for 50's right child, we've actually reduced the height of 50's right child. Woohoo! Right? It used to have height 3 and now it has height 2, so that's cool. Now we just build the rest of the tree just like it was before, we don't even have to think about it very much. 50 is still the root of the tree, 30 is still its left child, and 30 is still the parent of 20 and 40. 