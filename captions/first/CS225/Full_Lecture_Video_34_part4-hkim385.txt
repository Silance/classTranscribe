Due date, so you do next due next, the thing that is due next gets your attention.
It's some strange weighted average, right? Of due next, worth most, you know.
Oh, this, it's, like most, the one that makes you happiest.
Oh that'll be us, you know.
Um.
Uh, alright. So, you know, this is this function that determines the keys, the ordering in the priority queue can be lots of different things. 
Also, when we talk about graph algorithms, we'll be using a priority queue to order the uh to order the uh to order the order.
To plan the order in which we visit edges of a graph. So this is uh graph search. 
Graph algorithms in general tend to have a lot of priority queues. And that's foreshadowing.
That's, where are we going with this? Why did we talk about it at all? 
Alright, any questions about that? So I love this. 
I love that it's a rich conversation that has many different levels. 
And yet, somehow inherently safe because it's just computer science, not it's not like philosophy.
Alright, okay, so is that thing a heap? Is it?
If I'm keying on the characters, the alphabetic order of the characters. No.
What's your evidence?
B U oh the U is greater than L and D, right? Okay.
Alright, so I believe it. 
That that one is not a heap. 
Now what I want to know is  - what would be an algorithm for making that into a heap? 
What could you do? 
I'm giving you the data. 
You can assume basically that your data is laid out in array. 
Here's an array with all your data. Make it into a heap. 
What are you going to do? Yeah? Oh, why not sort it, right? 
You can use mergesort. Perfectly fine, perfectly reasonable idea. 
But we can do better. 
What is it mean to do better? 
What's the running time for mergesort? Big o of woah. 
Okay, you guys gotta write this down and put it on your mirror, okay? 
This can - even if you don't know the proof of this, it should just roll right off. 
You can, you can be talking about stuff you don't know, but this one should just roll off. 
The running time of merge -  watch me get it wrong here - the running time of mergesort worst case is nlog(n). 
So you're guaranteed nlog(n) for mergesort. 
It's not a great sort because it's very hard to do in place, especially if you're doing it in an array. 
But you actually did it in place in for mp3, I think, but your memory was all over the place. 
Alright, uh let's see. So, okay, so we could sort it, that would work. 
What else could we do? Yeah? 
Oh use heapify. 
How would you use heapify? 
What would you do? 
What is, what what how would you use heapify here? 
How would you use heapify? 
Oh, heapify down through the - it turns out that doesn't work. 
Okay? Yeah? Very good, very good. 
So the other thing you can do is pretend like, pretend like this is just data that happens to be sitting in memory and do repeated insertion into the structure. 
So first we've got, an empty heap. 
And we're going to add B to it. 
Okay? Well, there. We did heapify up from here. Fine. Done. 
Then we're going to add U to it. 
And now we can look at this part and say okay that's a good heap. 
Then we can add I to it. 
And that's a heap. 
And then we add L to it, and what happens? 
No it's fine, this is fine. 
You have to swap, right, but you're inserting. 
So you get heapify up for free. 
So L and U should swap. Okay. 
And now that's a heap. 
And now everything up to here is a heap. 
Okay, so do you see how this would play out in the end? 
One at a time, you're just going to add each one of these. 
It's like uh you know however many vertices there are here, inserts into the structure. 
Okay, do you like that?
