what characteristic of a heap allows an array based implementation, got it? yeah. [student answer]. That's right it's a complete tree. now what that means in fuzzy land is "you know this tree has no gaps in it, it's like we took all our data and laid it out in level order until we ran out of data", right? ok, so it's the complete nature of this tree. alright. and then finally, what is the characteristic ordering of a heap. how do you know, when you look at this, that this thing is a heap? do you know? increasing, what's increasing? that's a key word, what's increasing? kind of, yeah. every path from... root to leaf. that's right. every path from root to any leaf is an increasing path. alright, so i'm going to wave my magic wand here and uh... For every observation we've made about these mean heaps we can make a parallel observation about a max heap but i;m never gonna talk about max heaps, oh wait. alright, so, there are parallel explanations for max heaps and you may see them. you may see them in. um... if your doing online studying for things. some people, some instr... almost no instructors will use both min and max heaps, uh.. but some instructors will use max heaps instead of min heaps. okay! let's see. so. last time we talked about an algorithm for removing the minimum from such a structure but we never wrote the code to do that. alright, so, where's the minimum in the head? where's the minimum in the head? at the root, that's right. it's always at the top. so if one of our function in our abstract data type is remove min, that means all we have to do is grab that node from the top? easy peasy, right? but the problem is, if we actually remove it, we break the heap. ok. so our algorithm was to take this last value because it doesn't ruin the completeness of our tree to do so. take that last value and swap it's key up into the spot previously occupied by the minimum. okay. now do you like that? okay, you like it, but only partially like it, right? cause in a way it breaks the heap property of the tree, yes, you see that? so do you remember how to fix it? yeah. heapify down, that's right. so this notion of heapifying the try is one of restoring this path ordering characteristic. so we're going to heapify that' eleven down. should i swap a five or six? i should swap with five because it is save to put five above six but not safe to put six above five. so i'm going to always swap with the minimum child. alright, so five comes up, eleven comes down. swap with the minimum child, it's always safe to do, so nine comes up, eleven goes down and then eleven is smaller then either of it's children so we're done. ok. any questions about that? was it good? okay, let's write some code, or at least look at some code. I can't remember how much is here. ok. 