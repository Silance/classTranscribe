Just like we said before. Okay, so I thought about this for a minute and I came up with this idea for a data structure to support this abstract data type. I set up this example into an array where every array entry is an identifier for one of the elements in the set. Now that's perfectly reasonable to do because we could either make this an associative array or we could keep a map of each of these identifiers to a richer key type. So it's pretty reasonable, actually, to be able to say, "Well, I'm gonna use the indices as indicators, as element identifiers." Okay? So the indices are element identifiers and now, take a look. 0, 1, and 4 have 0 as their data indicating that they all belong to 0's set. So in this case, 0 is the representative. Any question about that? Is it good? Okay, and you can see 2 and 7, oh look, and then 3, 5, and 6 perfectly fine. Alright, so what I want to know is from you what is the find algorithm? So I want to know a representative of the set containing 5.  I wanna know a representative of the set containing 5. How fast can you give it to me? Some representative of the set containing 5. Okay, well, I've got it stored here, that's true, but 5 itself is, too, but then I can't be sure if I use those, then I can't be sure 3 and 5 have the same representative, right? So, if I ask for the find of 5, I'm going return 3. How long does that take? Constant time, that's right. So, I can, if I get things set up like this, then I can implement find in constant time, because the find of 5 will return 3. Any question about that? Yeah? Yep, these are the indices, I'm going to call them IDs, but they're just indices, and then these are the representative here. Reps. Okay? Any question about that? Now that seems to work pretty great, right? Now, how about if I take a union? Uh, I don't know, it doesn't really matter. We're going to take a union of those two. So this is going to be the union of the find of 1, and the find of 2. Because I want to take unions of representatives. Just clean to do it that way. Alright, how do I go that in this case? What's my algorithm going to be? Yeah? Yeah, so I'm going to change the representative of the sets to be the same. That's right, they all have to have the same representative. I don't care which one it is but they all have to have the same one. Okay, fine. What am I going to change it to? What do you think? Raise your hand if you think I should change the representative of all of them to 0. Okay, raise your hand if you think I should change the representative of all of them to 0. Of all the ones in the new set. Okay, doesn't matter, but, how am I going to find them to change them? What's the algorithm for doing this union? Yeah, look. I've got to go, "Hey, should I change you?" "Should I change you?" "Should I change you? Yeah, I probably should." I don't have to change 3, right? Don't have to change this one. And I do have to change this one. I can't  think of another way. I can't think of another way of knowing what elements are in a particular set without just actually going through and looking. Right? So the union in this case is big o of n. Groooaaannnn. That's a groan. Okay, so let's see if we can do better. 