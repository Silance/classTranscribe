What characteristic of a heap allows an array-based implementation? You've got it, yeah? That's right it is a complete tree. Now, what that means in fuzzy land is -you know- this tree has no gaps in it. It is like we took all our data and laid it out in level order until we ran out of data. Right? Okay, so it is the complete nature of this tree. Alright then finally, what is the characteristic ordering of a heap? How do you know when you look at this, that this thing is a heap? Yeah? Increasing, what's increasing? That's a key word, what's increasing? Uh, kind of. Yeah? Every path from... root to leaf. That's right. Every path from root to any leaf is an increasing path. Alright, so I am going to wave my magic wand here. For every observation we have made about these min heaps, we can make a parallel observations about max heaps. Alright, so there are parallel explanations for max heaps. And you may see them if you are doing online studying for things. Some people -almost no instructors will use both min and max heaps, but some instructors will use max heaps instead of min heaps. Okay, lets see. So, last time we talked about an algorithm for removing from such a structure, but we never wrote the code to do that. Alright, where's the minimum in the heap? Where's the minimum in the heap? At the root, that's right. It is always at the top. So, if one our functions in our abstract data type is remove min. All we have to do is grab that node from the top. Easy-peezy right? But the problem is, if we actually move it, we break the heap. So, our algorithm was tot take this last value, because it doesn't ruin the completeness of our tree to do so. Take that last value and swap its key up into the spot previously occupied with the minimum. Now, do you like that? Okay,  you like it, but only partially like it, right? Cause in a way, it breaks the heap property of the tree. Yes, you see that? So do you remember how to fix it? Yeah, heapifyDown, that's right. So this notion of heapifying the tree is one of restoring this path ordering characteristic. So we are going to the heapify that 11 down. Should I swap a 5 or 6? I should swap with 5 because it is safe to put 5 above 6, but not safe to put six above five. So I am going to always swap with the minimum child. Alright, so 5 comes up 11 comes down. Swap with the minimum child. It is always safe to do so. 9 comes up 11 goes down, and then, 11 is smaller than either of its children, so we're done. Okay, any questions about that? Is it good? Okay, let's right some code, or at least look at some code. I can't remember how much is here.