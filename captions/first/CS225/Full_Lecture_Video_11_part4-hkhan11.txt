Yes. Yes very good so the code is identical except for type information. what else do you notice about this code? yeah? you. Very Good. yup. It actually doesn't do anything. Neither function actually does anything. How can I fix that. Well fix that one first. How can I fix that? Pass by reference. don't say pointer to me. Alright good. So lets talk about the first point in a little bit more detail. So this is fine right to have these two functions that do pretty much the same thing. In fact if somebody were asking you to include these two functions in an mp. You'd go oh yay. they are about the same. I can cut and paste my solution for one and I've got the other one done yes right? The problem is that then you have to go back through and kind of check and make sure that your type information is updated correctly. Now the compiler is gonna help you mostly with those kind of bugs but its still a pain in the neck. And in fact if somebody came down and said there is new technology for swapping unlikely to happen but it could. Somebody came down and said there is new technology for swapping, a drawback of doing it this way is that you would have to go and find all of these plot functions and change them right. take advantage of this new fangled swap algorithm ok. yes its artificial. Alright so, code re-use is important for maintenance for improvement and incremental improvement of code. and we admit here that they are about the same. so how on earth are we going to unify those two functions into one thing but still allow for type information to be recorded in the code. and the answer is that C++ provides syntax for passing as a parameter type information. type information into the function. ok. alright so how does this work? I have my same main except that I am writing a single swap function. the way we tell the system exactly how we want swap to work is we have this alternative syntax for parameterizing type and we put it between angle brackets. So first you have the type parameters and then you have the value parameters. similarly we would do char and I'll tell you right now that if you forget to do this, when the compiler can it will infer it for you. So sometimes its not the case that you'll see those angle brackets even for a templated class. The system can infer it, it will. So now that's how you use these template functions. How do you define them? Well you prepend the function signature above the first line and it becomes the first line. With this keyword template. this is a key word. Class which is also a key word but it could be type name instead










