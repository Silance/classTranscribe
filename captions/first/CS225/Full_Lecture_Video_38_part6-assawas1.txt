umm so I think so the question is how well do we need to know this so absolutely you should know that the tree has n-1 edges. connected acyclic graph has number vertices minus one edges that should be a back pocket result. Should you be able to prove it. This is kind of I think an accessible proof. Because you can draw a picture that will guide you through it. Draw yourself a little picture and give yourself labels to argue about and then just put it all together. Should you memorize it? No, you shouldn't. Should you know how to do it? I think so. I think you should. CS347 demands much more robust proofs regularly so if this is a on-ramp to that kind of argument then you know so be it. I think it's appropriate. Yeah? Where? Right here? Right here? huh? This one right here? Look this one? Inductive hypothesis. Oh my gosh. I'm sorry. I'm doing this at me not at you. who knew. you could be unclear in that particular way. anything else? yeah? Right here? It's the number of components. So choosing the vertex and let d denote the degree remove the edges, partitioning the graph into d+1 components so I'm adding up component zero to component d the last one all the edges. Alright, we are good? It is what it is. Ok let's move towards implementation. I want to say little thing about implementing graph. You have been implementing graph ever since about MP4 I believe. Yeah! mp4 where you did flood fill. You were just operating on a lattice-shape graph that we think of as an image, right? It's a pixel together with its neighbors. Each pixel is like a vertex. Each neighbor represents an edge. You already operated on graph. That is extremely common where the graph implementation itself is implicit in the application. so there maybe lots of instances where doing graph algorithms where you don't necessary have an explicit graph data structure that you are gonna point to instead you will talking about shape or who knows what else? state in a game search engine or something like that. graphs are often not explicit in your algorithms. All of that said, there are some classic results that arises from classic implementations of graphs and we have to talk about those because everybody in your future world will expect you to know about these particular graph implementations so we will talk about them so we are going to have an abstract data type that is a graph. The data associate with it will be some structure that reflects the vertices often time it will just be a map or hash table of vertices maybe it's just a vector where each vertex identifier is an index. Who knows. opened to application. doesn't matter that much. same thing with edges. You have to have some structure that stores all the edges in your graph. Now what is that? I don't know. Maybe it's a hash table again. alright but then you also need some structure that reflects the connectivity of the graph. this is where we are gonna spend a lot of our energy. This is like a look up table for data about the vertices. This is like a look up table for data about the edges and this is some structure that keeps track of how the graph is connected.