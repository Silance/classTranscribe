And nathan what are you thinking? It is also n log n, yea this is nlog n, Lets talk about why. You're effectively calling heapify up and you are going to call it on every single piece of data. Look at all of these leaves down here that are going to have to make a trip all the way up the tree, right? But this is what you successfully have the data and they are going to go all the way up the tree. So that is, you go up log(n) cause this is n over two things or big oh of n things each of which goes log(n) up the tree. Alright so that is not satisfying so why are we having this if the best we can do is nlog(n)? Okay, So It is the best we can do, what is better? What's better than nlogn what we are going for is the ability to take an array of data like this and create a heap out of this in linear time. So i have a way of giving you a hint about this. I need a volunteer. I need a volunteer to come to the front of the room. Oh this is good on a Friday, hurry up, now you know you want to do it. You are just kind of afraid to. Raise your hand if you are afraid to raise your hand because you are afraid. Okay you are up. Okay. Now what I want you to do is point not to well you can choose what you point to between entry in the array or a vertex in the heap that is already a heap. It is already a heap, so the root of a sub tree that is already a heap. Okay that is what good alright, so d is already a heap right, okay fine. Put another one. That's already a heap. Okay good h is already a heap, so point to another one. This is a lot of pressure isn't, Ill give you a hit there are more higher up in the tree. Okay, Very good no no. Higher up in the tree. There are no more higher up in the tree. All of those are already heaps okay good, thank you. Yeah they are already heaps. Can you see that? yeah thank you very much. Can you see that they are already heaps? And they are very cheap heaps. Right? You know with H are just blocks. The leaves are already heaps. So that means when I run into a node that is no longer a heap. This one is already a heap, Already a heap. How about L, is L already a heap? Thank you. How can I fix this? How can make it so that this node this vertex right here, might hold a different key, but it is the root of something that is already a heap. Heapify Down that's right. Heapify Down on L. Okay? Heapify Down on L. A comes up, right? Okay fine, then we have to do it here, heapify down on I. Then we have to do it here, heapify down on U then on V. Okay? Any question about that? Is this nlog(n)? Feels like it could be right? It feels it could be because V's trip to the bottom is going to to go all the way down. This could go all the way down to the bottom. The difference in this case is only vertex that has to go all the way to the bottom. Instead of all of the leaves coming up in the other instance. Okay? So let's see if this actually gets us linear running time. Okay? Before we do that here are the three things. Here are the three alternatives. That is good planning on my part. Have the answers on the other side. Okay, sort the array big oh of nlog(n). Sort the array, then you can argue. Uh oh. No don't you cross over. Huuuh. Nooooooooo. Noooooo nooo nooo. It's not that kind of Friday.