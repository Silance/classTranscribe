Umm, So I think, so the question is, how well do we need to know this, yes? Is that right? Um, So absolutely you should know that a tree has (n-1) edges. okay? Connected acyclic graph has number of vertices minus one edges. Thats should be a back pocket result, okay? Now, should you be able to prove it? This is kind of an accessible proof, because, we can draw a picture that will guide you through it. So the process of doing this proof is, draw yourself a little picture, give yourself labels to argue about, and then, just put it all together. Okay? So, should you memorise it? Well no, you shouldn't. Should you know how to do it? I think so. I think you should. CS 374 demands much more robust proofs regularly, so, if this is an on-ramp to that kind of argument, then you know, so be it. I think its appropriate. YEAH? Where, right here? Right here? Right here? huh? This one right here? Look, this one? Inductive hypothesis. Oh my gosh, I'm sorry. I'm doing this at me, not at you. Who knew you could be unclear in that particular way. I'm sorry. Alright, anything else? Yeah? Right here? Its the number of components. So, choose any vertex and let D denote its degree, remove its incident edges, partitioning the graph into D+1 components. So, I'm adding up from component 0 to component D, the last one, all of the edges. Okay? Is that alright? Alright. You good? It is what it is. Okay, lets move toward implementations. Alright, I wanna say a little thing about implementing graphs. You have been implementing graphs ever since about MP4 I believe. Yeah! The MP4 where you did flood fill you know. You were just operating on a lattice shaped graph that we think of as an image. Right? Its a pixel together with its neighbours. Each pixel is like a vertex. Each neighbour represents an edge. So, you've already operated on graphs. Now, that is extremely common, where the graph implementation itself is implicit in the application, okay? So, there may be lots of instances where doing graph algorithms, but you don't necessarily have an explicit graph data structure that you;re gonna point to. Instead you'll be talking about shapes, or who knows what else. States, game search engine, or something like that. So graphs are often are often not explicit in your algorithms, All of that said, there are some classic results that arise from classic implementations of graphs and we have to talk about those because everybody in your future world will expect you to know about these particular graph implementations. So we're gonna talk about them. Alright, so we're going to have an abstract data type that is a graph. The data associated with it will be some structure that reflects the vertices. Oftentimes this will be just a map or a hash table of vertices. Maybe its just a vector, where each vertex identifier is an index. Who knows, open to application, Doesn't matter that much. Same thing with edges, you have to have some structure that stores all the edges in your graph. Now what is that, I don't know. Maybe its a hash table again. Alright. But then, you also need some structure that reflects the connectivity of the graph. This is where we're gonna spend a lot of our energy. So this is like a look up table for data about vertices. This is like a lookup table for data about edges. And this is some structure that keeps track of how all the graph is connected.