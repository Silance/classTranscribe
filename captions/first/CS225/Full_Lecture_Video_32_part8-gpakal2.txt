AVL Tree. Anything else? A b-tree, yeah. Sort of. But, if our data is so big. If our data's so big, it doesn't fit in memory. It's not gonna fit in memory here either. So, mostly AVL trees, maybe a linked list. But those have been bad for a long time. Okay, so, primarily. Primarily it replaces an AVL tree. you know what, I'm sorry. I need to go backwards. I need to reemphasize something. I need to go back to here. What's the running time of finding something in a hash table? If alpha is constant. If alpha is constant, what are these running times? They're constant. That's right. When somebody tells you hash tables have constant time access, it's because that load factor is held constant in this using this strategy. Okay, so, this resizing strategy is used to hold alpha constant. Which means find is constant. Insert is constant. And those are probabilistic results so they're average results. Yeah? Sure. No, it's what we're rehashing. Separate chaining is open hashing where you just hang your data out. We talked about it last time. Okay, it was the first collision resolution strategy. Alright, anything else about this? Let's do a lecture like this today. Let's do this. Yeah, Mike? You're not going to because your table is going to be fairly empty. Your table's just gonna be over half full or so. Yup. Yes. We're never...yes, it gets smaller. So we're gonna put an upper bound on alpha. Alpha's never gonna be worse than 2/3 which means those functions are never gonna be worse than whatever that is. Alright, what else? Yes? The absolute worst case is usually just ignored. Yup, and if I were implementing a hash table from scratch, I'd like put full tolerance into it like use two different hash functions and use the better of them say, for example. Yeah? So the question is if alpha is one less than the table size over capital n. Still, if I take big n over little...I mean if I take n-1 over n and I keep it there, that running time is gonna be constant but really bad. So, I'm still gonna keep alpha fixed relative to the table size. So, there is no n. There's no n in expressions for running time. Because alpha is gonna be constant even if it's n-1 over n. Even if it's really close to one. I'm going to control alpha. Alright, what else? Alright, I have a puzzle for you. Let's go to a puzzle. Puzzles are always safe. So there is the constraint. When we use AVL trees, there is a constraint on the keyspace that does not exist for hash tables. And I'm going to...uh, so there's a constraint on the keyspace for any binary search tree, in our case, BST, that does not affect hashing. And to evoke the idea, I'm going to do this. And ask you what did I do at every vertex here in an AVL tree? What do you do at every vertex, every opportunity of branching in an AVL tree? What do you do? You decide if it's bigger or smaller, you make a comparison. So, AVL trees require comparable keys. That constraint doesn't apply to hash tables. So, AVL trees...BST in general. AVL trees require comparable keys.