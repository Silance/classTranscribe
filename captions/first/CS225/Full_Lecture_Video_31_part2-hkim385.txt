If two keys map to same small index, and by map to I mean via the hash function. Okay, any question about all of that? Alright, so the first part of our focus is going to center on the hash table itself, and the sec-or the second, the first part of our lecture will be centered on the hash function itself. The second part, we'll talk about collision resolution strategies. Okay? Collision resolution strategies. I have a cold, so.. Alright, any questions about all of this? Alright. So. Uh hash functions, this is the story on hash functions as I know it. It's going to necessarily be an incomplete story, because guess what? There are people working for all kinds of different large entities, spending their entire lives working on good hash functions. So, in this hour, we're not going to touch on all of the complexities involved with creating good hash functions. So it, people who are interested being cryptography are doing hash functions, mathematicians - uhm, people who deal with big data want really good hash functions with great characteristics. So, this is just a glimpse into their world. There's a whole career out there waiting for you centered on this material if you would like. I'm intrigued by it, especially the big data aspects of it. Alright, uh let's see. So, what does a hash function look like? Typically it consists of two parts. A hash, which takes the key and finds some integer, okay? Returns some integer. Together with something that shrinks that integer down into a space small enough that we can store it. Okay, so a compression which is a function mapping that larger integer into the array, cell zero to n-1, and this is almost always - and it will always be for our class - just the mod function. This is mod n. Where n is the table size. Okay? Any question about that? Alright. Oh, there's a yawn already. Who yawned? It's Friday, I could yawn too. Okay, so turns out that choosing a hash function is tricky. It's hard to choose good ones, and I'll talk a little bit about that on the next slide. There's a whole, again, a whole lecture of what are some classic bad hash functions, uh, that have been created over time and extolled as "the next greatest thing for hash functions" and then found to contain periodicity that actually results in very bad behavior. Uhm, we'll talk a little bit about that in a minute. So, we don't want you to create your own. The "yet" is not really well stated. It should really be "unless...", where the unless is that you understand your key space and it is small enough that you can create a bijection. Unless you can create a bijection, in which case you should, uh, uh, make your own hash function. Unless you know your data well enough to create a bijection. And notice that that really means also that your data has to be small enough that you can create this bijection. Alright. Uh, so what must a good, what characterizes a "good" hash function? So these are the characteristics of a good hash function. Uh, computed in how much time? How much time are we going to give the function to run on a key? Constant time, that's right, very good. It must be computed in constant time. It must be deterministic. What's the opposite of deterministic? Probabilistic. Yeah, good. Or another word for that is? Random. Right? So the opposite of deterministic in this case is random. Now, think about what this means. Uh, what this means here is if i == j, if index i is the same as index j, then it must be the case h(i) is the same as h(j). Okay, that is, there is no dice roll that says uh there is no dice roll that says what the hash of the index should be. If we plug in four, we're going to get the same value out every time we plug in four. Okay? Alright. Uh, we'll talk about the the what would happen if that were broken in just a minute. Okay. Good hash functions also satisfy the SUHA. I like saying it, and so I'll say it again and I'll tell you what it means. SUHA. Simple uniform hashing assumption.