Analysis for the argument about how good the algorithm is should be in terms of n. So we can make these arguments if we understand if we completely understand the functional relationship between h and n. Now here's what we're going to do. H in this context represents the running times of our algorithms. So H is a running time. Its a stand in proxy for the running time. We recognize that its you know in some constant factor of h, we don't know what the coefficient in front of h is. But what we're going to do is argue that h is at least this much as a function of n. For running time, it's at least this much as a function of n. Now what does that mean we're doing? WE are in official terms putting a lower bound on the running time of an algorithm and we're saying that if somebody comes to you and says they have a better algorithm that is they say they have an algorithm that is less than whatever we come up with for F(n), you go nuh uh, that's not possible, your algorithm must not work because no such algorithm exists. That's what a lower bound gets us. Let's see. No algorithm can do better. It has worst case performance. Alright but at the same time, at the same time we need to argue about the relationship of the running time on the top end. That is, we want an upper bound on the running time because that in fact is called a tight upper bound because that's actually the currency we use to argue which algorithm is better. I've got a structure that implements the dictionary in constant time, that means an upper bound, its a worst case constant time. I have an algorithm that, oh yeah. We'll talk more about that in a minute. Any questions about that? Alright. So as a reminder we're arguing about height and because our argument is going to be recursive and need this, I want you to remind me what a height of an empty tree is. Remember what we have defined the height of an empty tree to be. 0? -1. That's right. If that bothers you, if that bothers you remember that the english definition of the height is the length of the longest path from a root to a leaf, and an empty tree has no root, so this is sort of an indeterminate question in the context of our understanding of height, so we get to make it anything we want. So we choose something that's convenient that makes this recurrence work well for us. Alright any question about that? All of that? Okay. Let's see. It turns out we're going to do this one first and this one second, it turns out that this is kinda of a complex tends to be a complex argument. And if instead we equivalently argue this.