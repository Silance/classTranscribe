Umm, but it also guarantees that same running time, okay? So now, let's write code that does this. Let's write code that does. Um, oh and we're not going to prove the log n here. We're going to move right past it, we're going to be satisfied with this moment of having log n, but we're not going to take the time to prove that because we're going to do better. Alright, find has not changed so the code for find didn't change at all but the running time of find is going to change, we didn't even touch it and its running time is going to change. Alright, so here is union by size, union by height could be done similarly, I don't even think we ever ask you to do it I think we always ask you to do union by size. Notice that the new size, the sum of the values at the root just like we suspected might be the case, if so we've got this helper function "is bigger" that merely takes the negative of the value in the root right, and compares them. But I got a little bit lost in the inequalities there so I wanted to test that separately and make sure it did what I thought. So let's see this is this means... root 1's tree has more nodes... than root 2's. Okay. Alright, root 1 is bigger then, we're going to point root 2 to root 1, and then root 1 gets the new size. Okay, any questions about that? Otherwise we'll do the opposite. Any question about it? Okay what's the running time of that code? 

Yeah, it's constant time, good. Because there's no traversing going on, there's nothing about the size of any of these structures that affects running time here, right? We can look up the sizes are just array look-ups. The comparisons is a constant time thing, a conditional evaluation then we got a couple of assignments. So this is still a constant time operation but it has the effect of maintaining the trees as short trees so now we can say find is big O of log n. Do you remember what was the best we had before we started using these up trees? The naive implementations of I guess it was probably using an array. Do you remember what it was for using an array? It was constant time for size, but big O of n for taking the union. Okay. So this is using an array. 

And you can go back using an array naivelyish. You can go back and review that. Okay. Do you like this better? Kind of depends on which one you do most often, right? And in fact in this sequence of using these structures you can only take unions so many times, so this doesn't feel quite satisfying to me yet. Okay. We shouldn't stop here. We should do one more thing. Let's suppose we do a find of 4. 