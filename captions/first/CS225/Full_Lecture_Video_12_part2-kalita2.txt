There we go ok? And it's executable code. Ready to be linked with anybody who would like to use it. Alright, fine! Well I know somebody who would like to use it. This main would like to use that compile code. All that has to be done is sphere of h has to be included. sorry! Include sphere. h here. And then these 2 effectively are compiled together into main.o. How do we get sphere and main linked? Yeah but linker does it for us. So the linker creates the union between main and sphere. Ok? All of that process is orchestrated for you by your make file. That's the whole point of the make file so that you can do all that separately and not have to type it out every time when you are trying to compile your code. Ok? Now the world is a little bit different in the case of compiling template. Now we got sphere.h and sphere.cpp and main.cpp. But, if you noticed on the previous page, the compiler detected that it didn't have a plus operator for integers and strings. And, what's going on there is that the compiler needs to know ahead of time exactly how and so, you got a compiler error, adam wasn't created. The code for the adam function was not created. Now the reason that that happened because the code for all of the use of your template functions must be visible to the compiler all at the same time. That means that main cannot be compiled separately from sphere.cpp. And more importantly sphere.cpp cannot be compiled separately from main. And more importantly sphere.cpp cannot be compiled separately from main because in order to make the sphere class you need to know how spheres are used. The type of thing that you're passing into sphere to use for the various.. i don't know. Falls apart a little bit here. So what do we do? The main principle is we do not expect different behavior from client codes. The client code is still going to say count include sphere.cpp. Ok? Sphere.h. We don't want the client to have to change. So, the client is still going to say count include sphere.h. But it can't just be sphere.h. It also has to be the implementation. How are we gonna do that? What are we gonna do? Hmm.. When we compile this, we're gonna compile it all together and all the code has to be visible. We don't want the client to change code. Change behavior. Yeah? Yeah. Look at this. The only thing we are including is sphere.h. So that is the only code we get. So the only way that include statement can include all of the sphere class definition is if we say count include sphere.cpp at the bottom of sphere.h. And now when you do this count include sphere.h you actually get all the code. And then you compile main.cpp and all the compilation happens at once, there is no use of the linker in this case. Yeah? Because the declaration of the class has to come first. So you have to have the class declaration, the implementation of the member functions and then the client code that uses that. Ok? Alright yes!