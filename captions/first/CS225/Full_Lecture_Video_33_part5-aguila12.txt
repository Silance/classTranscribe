So this characteristic is true, recursively. OK but, but.. were actually not going to end up relying very much on this particular depth definition. The focus of the algorithms that we write on this structure are going to rely on this and on this. OK. Any questions about that so far? Here's a quick question are complete trees full? Is every complete tree a full tree? No, good. Is every complete tree a perfect tree? No. Is every perfect tree a complete tree? Yes. OK good you see where that conversation is going right? OK so let's talk about implementation of this thing and what I want to know. What i'm going to ask you to do is imagine how you would implement this thing and then, huh, tell me what the primary private member would look like in your implementation. OK so think about what your, how you would implement it and then tell me what the primary member or the the primary private member of that implementation is. Anybody want to offer something? Tell me what you think. What do you think? It's a treee! So what is, how are you going to characterize this tree in code. You're not going to, you don't want right? I don't wanna. Have you done things like this in the past? You're not talking to me? It's OK to be wrong. In fact lets day something that is wrong. I'm going to implement this tree using an integer. OK that's wrong. OK now that's out of there. So now somebody venture were we're past that, so somebody venture something. You're implementing a structure like this that has two functions what is your primary private member going to be? How are you going to hold the data? A tree node? Is that what you said? Thank you so much. Now I owe you a cookie. Did you say that? He said it? OK now he owes you a cookie. OK. Alright very good. Well.. so a tree node pointer called say root, perfectly reasonable implementation, perfectly reasonable implementation, except that we don't have to do it that way instead. ooohhhh. What's the implication? We can use an array. We can use an array. Now the thing that gets us this, is  that the tree is complete. OK. We know everything there is to know about the structure of the tree. That is not so true in AVL trees and BSTs in general OK. But in this case we know everything there is to know about the structure of the thing. So we're going to exploit that and say "Hey I know where the children and parents are". We're just going to lay it flat out in memory. Now in MP6 that is true as well. We are going to use a vector an array to implement the tree but it is slightly different. Where is the root in this implementation. Where is the root? Right. Early on in the array, the front of the array. Right. In MP6 the root is kind of in the middle and all the nodes in the left are less and all the nodes to the right are greater in some sense. OK. So it's a little bit different of an interpretation of using a flat, a flattening the tree. But it sort of takes advantage of the structure speed of an array in a, for similar reasons. OK now. Huh in a pointer based implementation of a tree. It's important to have the following pieces of information. You need instant access to a left child