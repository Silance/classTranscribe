We can talk about that later. the question is about the conflict exam and my understanding is that there are university rules for qualifying for the conflict exam and of course we're going to follow those university rules, so you probably either have a conflict or you don't so i don't know where the fuzziness is. our exams at this point are so consistent distribution wise, they're consistent over semesters even. in fact, i'm kind of anxious to see. this semester is the first time in a very long time where i'm not writing the exams, so i'm really interested to see at the end of the semester whether the grade distribution over individual exams when we look at the whole semester if they deviate, i think they won't very much, you know, the first exam from my perspective had a pretty perfect distribution, so you shouldn't expect wild differences in averages. okay shall we work? yes, let's get it over with, right. okay, i'm going to ask you on monday what you did this weekend that gave you joy. so i'm just gonna ask you, and i want you to think about that for this weekend a little bit. alright, so we were talking about hashing, and i wanted to kind of clarify the perspective on hashing, i wanted to kind of paint a picture for you. We were using these structures called hash tables to implement a dictionary. now when we implement a dictionary, it means we're providing to the client - that's this code, the users of the dictionary - particular functions. now in a dictionary, all those functions are key value centric; they depend on having a unique key, and they are a way of accessing values or data associated with that key; that should all have been review, you should be like practically falling asleep in that particular discussion. now, what needs to be clarified, i believe, is that a common interface to a dictionary is via an associative array, kind of like this, where we treat the key type as the type of thing that can be an index. okay? is that clear? makes sense. alright, and that's very very common. so that associative array is a particular interface to a dictionary. now all the stuff we talked about last time is concerned primarily with the implementation of this ADT and its interface, and that implementation itself is referred to as a hash table. so this is the picture that we have. Here's the client code, here's what they know, they can do dictionary-type things here; but here's what's going on behind the scenes. Behind the scenes, we have a class Dict that receives via the functions; it receives a key and a value. It receives a key and a value, so input into the member functions of this class are K and V. So here's what happens. K is sent off to this hash function where a small integer is created and that integer is used to denote a place in the array, into which you're going to store the value. Now the problem that we began to talk about last time was what happens if your hash function is not a perfect hash function? That is, especially if it does not, if it is not one-to-one. So we might ask a question, "what if h(k) is not 1-1?" we're going to handle that and talk about that later today - this is foreshadowing - by coming up with a collision-resolution strategy. that is, what do we do when the lack of 1-1'edness in our hash function appears, or is manifest by the particular set of data that we get? and that's the stuff today. 