Yes? Very good. So in the table, it's.. So remember that roots are indicated by negative numbers, okay? And in the table, 6 is supposed to be a root. Okay? And not 3. In the table it says 6 is 3's parent, okay, so that's the bug. That, that was my intentional bug. Anybody else find something, something different? Some other error? Okay, so notice that these are not ordered trees in any sense. So, it didn't matter where I drew the 2 and the 9 here relative to one another. There is no notion of a left child and a right child, or a middle child, or an early middle ch- there, you know. So this tree is not ordered, it's not necessarily binary, though this, uh, this examples happens to not have any non binary nodes. Uh, let's see. It is directed, though. That's the key part. Alright, any questions about it? Alright, let's take union just to remind ourselves how you take union, both in the context of the model and in the context of its representation in memory. So I want to take the union between these two sets and do something, and do something that makes all of these in the same tree. So how should I do that? I've got these two trees, what should I do? What should I do? Yeah? Yeah, make one of the roots point to the other. Now, should I do this or should I do this? Should I do this, this one? Okay, and now I have to like turn around. Oh, wait. Okay. So your opinion, I should do this? Okay. Um. Alright. You think 5 should point to 7. Okay, now, what I want you to get from that little exchange is that there was a choice to be made, and for now, we're going to make an arbitrary choice. Um, a principle, but arbitrary choice. And I'm just going to have the one on the left point to the one on the right. Okay. But you should recognize that it, sort of, you know, that was arbitrary. Okay. Finally, if I say something like "the union of 2 with 7", what I really mean is the union of the set containing 2 with the set containing 7. So I need to call find() in order to get the appropriate representative of that set. Okay, any question about that? Alright. So, uh, and the reason I bring that up here is because when I talk about these functions and when we discuss running times of these functions, we want to find() to be decoupled from union(). When you implement these things in mp7, you're going to throw a find() inside, because you don't want to have to demand that the client do this every time. So, there'll be a slightly different specification for the union function in the mp than there is here. Okay, but I want to decouple them because I want to be able to talk about running times separately. Alright, any question about that? Okay. So let's write some code, yay. Alright, so.. The function find() is going to take a key or a element identifier, some kind of identifier, and it's going to return the root of the uptree. Returns the root of i's uptree as a representative. Okay. Now. Woah, look at this code. This is really cool. If, if the value in the array at i is less than zero, it means that i is a root, right? That's what we agreed on. In which case, we're going to return i. Otherwise, we're going to walk one step up the tree. Okay, so, we're going to find() on i's parent. 