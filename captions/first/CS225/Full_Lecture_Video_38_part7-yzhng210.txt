OK, now, functions on such an abstract data type are many. There are many, many. At minimum, we have to be able to insert vertices and edges, remove vertices and edges.
It's very common to need the set of incident edges given a vertex. So, this function would return to you, would return, a set of incident edges. Or an iterator over them, for example. But the way you should think about this function is as returning a set of incident edges, okay? areAdjacent is a boolean, that tells whether or not v1 v2 is a edge in the graph, so you can just test. And then finally, these two we will talk about them more, they are only for directed graphs. For now, we are going to assume that graphs are not directed. Okay? They are undirected. Alright, any questions so far? This is the setup. Here's how we are gonna do this. We are gonna look at three different implementations. And we are gonna compare a few functions across all of them. Now, we are not gonna look at all the functions on the previous page because we would fall asleep :) These functions are adequate for getting at all the issues. OK? Alright, implementation one is called an Edge List. And basically it works like this. It is a structure for this (Vertices), a structure for this (Edges) and we are not going to specify any particular reflection of the connectivity. OK? So, we just gonna have maybe it's a hash table, constant time access to the vertices. Constant access to the edges, and that's our structure, that's it. Okay? Now, what does it look like? What does the implementation look like? The data associated with each of these things. Well the vertices is just a list of vertices, maybe we'll associate a weight with them or a time they were created, or any other data you want. But for now, they are just a set; it's just a set of vertices, or map of vertices. The edges though, are more interesting. Edge a, for example, will contain data that reflects its end points. So we've got u and v here.  b has v and w. c has u and w, and d has w and z.  We are going to engineer everything so that (u, v) is the same as (v, u) so it doesn't matter which order I put those in. Alright, any questions about that? Yes? So that's more complex, that actually does... So what you are suggesting... So the suggestion on the floor is how can this be a good idea? Wouldn't it be a better idea to list for each vertex its set of incident edges. And Yes, that would be a better implementation, but we are not gonna do it yet. We are gonna be stupid at first, 'cuz that's what we do around here. Okay? We do things naively first and then we move to complexity. Okay, so I want to know how long does it take to insert a new vertex into this structure. Here, I did it. How long does it take to add a vertex into this structure? Constant time. Very good. Okay? Just adding into either the array or the map; you have to be able to assume that it is constant time. Okay? Fine. How about removing a vertex? Oh, and I'm gonna use this notation. The size of the vertex set is n, the size of the edge set is m. So there are n of these, and m of those. Okay? What does it mean to remove a vertex? Here, there I removed v and I have to remove all of its incident edges. So removing a vertex really means remove the vertex and incident edges. So how long does that take? Big O of m (O(m)) is correct because we have to search the structure right? Oh, there is a v, there is a v, and no more v's. Okay? We have to search that structure. 