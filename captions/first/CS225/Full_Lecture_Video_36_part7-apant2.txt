Okay, if we do a find of 4 we recursively walk all the way up the tree, right? But this is recursive process, which means after its complete we have to fall out of the recursion and after its complete we know about 10. So in a post order way, in a post order way we are going to do the following: when we first look at 4, were going to do a find on 4's parent, and after that is successful we are going to connect 4 to that parent, okay? Then, going up the tree, there will be a find on 2, after which were going to connect 2 to that root. Then, there will be a find on 7 after which we are going to connect 7 to the result and then there will be a find on 9, after which we are going to connect 9 to the root. Now, this is  what that looks like after that process; you could probably draw it too, but i'm just going to redraw the whole thing , um with the blue err[?] taking into account the correct arrows. So, 10 still has 9 as a child, and 11 as a child, but now it also has 7 and 2 and 4, and 1 points to 9 and 8 points to 7 and 3 points to 2 and 5 and 6 point to 4, and nothing points to 11. So we took this tree whose height was 1 2 3 4 5 whose height was 5 and by doing a find on it changed it to have height 2, okay? Any question about that? Alright, what do you think the code looks like? So this is the old code, the old union by size; we're kind of ignoring it right now. This is the new find, except that its the old find with a few spaces thrown in; what goes in those spaces? What goes in those spaces? Remember that what were doing is changing the parent of the current node to be the result of the find. Okay, so lets take that sentence and put it in code; we're going to...oh here's the result of the find. We're going to change the current parent, current node's parent to be that. And that's it. So this implements path compression. Boy, you guys are quiet today. Any questions about it? Yeah?