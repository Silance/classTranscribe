4 to 8 gigs? Is that about it? Okay, assume you can only use half of that for, I mean at most, assume you can use a fourth of that for computation of any one given program, that's probably even an overestimate, you realize that any data set larger than a couple gigs really merits some other storage. I'm not going to analyze driving records, that's whatever, it's kind of a fake application I think. Maybe it isn't, I've never really looked into it. So, not gonna look at this. The point is, the point of it is this: If you cant fit an entire AVL tree into this immediately accessible piece of memory, this RAM, this heap memory which is part of RAM, then your only alternative is to store it someplace else. Now, I'm gonna talk about that some place else, as if it is a hard drive. But, all of the conversation applies anyway. So here's where we were last time. We observed that if we have some balanced structure, this one wasn't balanced so I better make it balanced, if we have some balanced structure which we think is a reasonable way of accessing our data, but our data isn't close to us, that is that balanced structure doesn't fit in memory that is fast, then if we are going to do this sort of search for thirty eight, thirty eight may be out in some place where the communication cost is high, whether it is the disk or the cloud or whatever. Is that clear? Is that clear enough? This is high communication cost. That says high communication in the font that this pen chooses to write in. But what is also true about all of this sort of remote data is that you don't get just one piece of data at a time, you get a block of data. So even if you are only looking for key thirty eight on the moon, when you go to the moon and you come back, you come back with a whole bunch of stuff. It's just the unit of transfer that happens either via remote communication or via communication with your hard drive, or your solid state drive. So, here's the thing, you want to make sure that piece of data you get is relevant to your search, relevant to your application. And that's kind of where we were. So we're gonna define this structure called a B tree and into the B tree, into a B tree node, we are gonna throw not one key, but a bunch of keys. So you can imagine that this whole thing is a B tree node. And it corresponds to some linear function, it is some fraction of a transfer block from your disk, from remote storage. So this is some fraction of a block in remote storage. And the reason I say that it is some fraction, like a fourth or a third, the reason I say it is some fraction is because when you get the block you also need some other information too. Just like when you get a binary search tree node, you also get pointers to children, in this case you also get a collection of keys together with some other redirection. Okay, main goal, we want to minimize the number of reads from a disk or any other remote storage. Okay, I want to show you how these things work before we do a formal description and the way I'm going to show you how they work is by hopefully pushing on this link. Gnarley trees, that's new. What am I doing? That's not the one I want, I want that person but I want the big, and we just hope it exists at this point. 