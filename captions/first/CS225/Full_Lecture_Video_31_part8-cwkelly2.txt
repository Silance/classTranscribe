Good very good, so the observation is that if you have a whole bunch of things in the same bucket, if you have a whole bunch of things in the same bucket and you go to get your data out, you have to essentially search that whole thing to get your data. You have to search your whole thing to get your data, so the cost here could be a lot. We're going to record that observation in the worst case, so insert is always constant time because we're just going to plunk it in the front. But , in the worst case we might have to travel all the way down the list and if it's true that everything mapped to one cell, you might have to search it all. Any response to that? Any idea about it? You agree with it? OK so that's worst case, but how about under SUHA? What is SUHA say is going to happen here? How many do you expect if these things are uniformly distributed over the table, how many do you expect in each chain? At least two in the chain in this example, but in general if I tell you the table size is N, big N, and the sample size is little n how many do you expect and that's an average. On average how many do you expect in each cell? Right. Good. This is little n over big N and insert is still constant time. What do you think about this? What do you think about this? This is foreshadowing, this is important foreshadowing. Are these two the same? They're not? Raise your hand if you think these two are asymptotically the same. This is discussion, not competition, okay? And raise your hand if you don't think they're the same. Okay. The answer is it depends. Here's what I'm going to use to answer this question, we control the table size. You and me, we're the boss, we're the boss of how big this hash table is. So, we can always make it big enough so that this value is whatever we want it to be, yes? So, these two in this context are not the same because big N is not a constant. We control it and we're going to change it. This is foreshadowing, you might be able to imagine when we might change it. Alright any questions about this? Any question about it? Okay. Alright so seperate chaining you just plunk them all in and SUHA saves you is the short story. Alright here's another one. This is an algorithm that is a very big simplification of a class of hashing strategies, it's sort of the introductory one, it's closed hashing which means all your data will be in the table and here's how it works. If there's not a collision, you just map the key to its position. So sixteen maps to two, eight maps to one, four maps to four and thirteen maps to six and now life gets interesting. We're going to hash twenty nine to one and it's full. There is already something there, so we increase our additive probe number. This is a probe number and look at the next spot. Oh look, spot two is full too, but when you increase it again to three, there is room. So, we can put twenty nine there. Any question about it? So, where does eleven go? Into five, good. And how about twenty two? What is twenty two's life like?