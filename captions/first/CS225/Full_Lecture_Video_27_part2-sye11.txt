Okay, all right. Prove of concept. Now I'm gonna plug it in because  I like it. Now I'm gonna do 40 again, sorry. [...] That was fine. And then I'm gonna insert 76... I'm gonna make it look like as it was before. 76. Insert.
And now we're gonna insert 85. I didn't expect that part take 5 minute. Okay, ready? Are you sure you are ready? Okay we are ok. They do it a lot faster than we do. 
Now what I want is something you could insert... Let's take 85 out ok? Deleting 85, that's not working. I'll save you. That's out of balance. Perfectly fine. Now I want a key that insert it will result a right rotation. 52 would do it. Anything bigger than 36 or less than 75 would result a right rotation. Is that true? Yes? And anything in 75's left subtree can contain keys between 35 and 75. So... somebody raise your hand. Yeah, what number you would? 45, okay. 45, and inserting. That's not out of balance. Do the right rotation. Ok, any question about that? What happens if I insert 17? Nothing special right? 17. Finding the spot for 17, and checking to make sure that everything is ok on the way. 
So, going up is sort of like yelling out a value after you've processed the rest of the tree in a post order traversal. Okay, I'm actually doing this post order after the recursive call is made.
Does that make sense? And when you look at the code I'll be sure to point that out. So all of these, all of the valuation assumes the insert has actually happened. 
Ok, I wanna now a key that would result a double right rotation, in a right rotation, but a double one. A double right rotation, I believe there's only one key, I could be wrong, that could result in a double right rotation. 
