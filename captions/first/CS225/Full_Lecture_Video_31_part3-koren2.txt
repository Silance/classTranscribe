Now here's what it means, it means that your hash function basically spreads data out over the table. It minimizes the likelihood of collisions, of two things mapping to the same small index. Okay, now let me write the out mathematically. If I is not equal to j, that is if you pass in two different key values, then the probability that P(h(i) == h(j)), although it would be great to say its zero, is less than or equal to 1/N. Which means, suppose that i maps to this cell. If i i came along and h(i) is here. All we are saying is that the probability that j is no more likely to be here than anywhere else. It's equally likely for it to be spread out over the table. And the nice thing is, is that means its 1- 1/this. There won't be a collision. And there are all kinds of probabilistic results here that mean you can say with high probability that the table behaves well over a sequence of hashes. Alright any questions about that? Okay. It is the case that mathematicians spend most of their time under various constraints focusing on this particular aspect of it. This one is kind of a duh. This one, you know, you could get a good one here that took a long time to do, but this is the most interesting aspect mathematically. Okay i want to talk about the consequences of breaking each of these criteria.Lets talk about bad hash functions. Good hash functions have this and this and this. So a bad hash functions would negate that conjunction and would say that means either this is bad or this is bad or this is bad. What would it mean for this one to be bad? What would it mean in terms of the client code. The dictionary functions would not be constant time. We already have dictionary implementations that get us logarithmic time. They are Avl trees. We already have that. So, anything worse than constant time here, were kind of unhappy with. We are only willing to give the hash function constant time to execute. Okay what it would mean if this one were violated. If the hash function didn't do this? Think about it. You're going to insert something into a place in your table, in your array. If you want it back or you want to look to see if its there. If your hash function doesn't send you back to that spot, and sends you someplace else. You're lost.   Hash functions have to be deterministic in order to be functional. Again it could be the case that you search through the whole thing, but that's not better than what we already have. Alright. Finally what is the consequence of something not satisfying the SUHA. Of not spreading the data out over the table. A very high number of collisions to handle. In fact so many might be the case, that all of your keys map to the same spot and that would be, that's like putting everything into a linked list, perhaps. Alright we'll talk about that in just a minute. Okay, so not satisfying this means lots of collisions. 