Even if, even if uh the thing I'm looking for is not in the table. Okay. This one is for successful this one is for unsuccessful. Okay. Uhm up there, that same value, we would have to keep our, for that same number of probes, we have to keep our table only half full. Table only half for example. Any question about that? I'm used to having this discussion in the context of that applet. So I don't pretend this is particularly smooth. Alright. Uhh any questions? Is it good? So the idea is that this, these, probe based strategies work by, if you don't let your table get too full. Yeah, Nathan? No. That was just, you know, four doesn't seem like too many. Four's a constant number, seems like it would be quick right? And I can say to somebody, "Oh we'll never have to go further than four." Okay? It's a arbitrary choice. But it turns out, well, I'll save that punchline for a minute. Alright, any questions about this? Yes? So successful is if it's in the table, unsuccessful is if it's not in the table. So if you're looking for key that is actually there somewhere, versus if you're looking for a key that is not there, that's the only difference, okay? I, I question, maybe I shouldn't even break them out. Maybe they should, we should, just look at the unsuccessful numbers. Alright, any other questions about this, alright, any other questions about this? The takeaway is that if your table is not, if your table gets full, look how fast those val- those functions go up. But if your table isn't very full, you're in kind of a good shape for these things. Alright, so, uhh, let's be a little let's think about this a little bit. Alright, so, when we were talking about queues, and I, if I asked you, we've got this queue, what do I do if it fills, what do you say? What's your answer? What if the array fills? I should double the array, and copy the data, very good. Okay, that's what we used to have. Here's what we have now. I'm gonna change it up a little bit. So look, we're not going to let the array fill. We're only going to let the array get up to some alphabet we control, some load factor that we control. In practice, the reasonable load factor that is used is approximately two thirds. K, there's an analytical reason for using this, uhm, load factor but in practice, it's about two thirds. So. What if the array becomes more than two thirds full replaces the questions of what happens if the array fills. What if the array, um, is more than two thirds full? Alpha greater than two thirds. Now we don't exactly double the array and copy the data. We find the first prime greater than twice the array size, find first prime greater than twice array size. Because we like prime numbers, but we're not gonna, I'll explain that if you want. Umm and then, instead of copying the data, we do something a little bit different, okay? So I wanna do this example, so that we see what we need to do. So suppose we have hashed our values into this table, and we this hash function, h of k, is a hash of some kind mod table 5, which is 5. K? And we've hashed these three values into it. And another piece of data comes along. Now we're going to find the first prime bigger than twice the array size, oh look, there it is, and copy the data in, okay? So it's just a straight copy. What's the problem with that? What is our new hash function look like? What is the new hash function look like? It's H 1 of k, mod 11, now. Which means that you will never get these guys back, we changed the hash function. So instead of copying the data, so instead of copying the data, we rehash the data with our new hash function.