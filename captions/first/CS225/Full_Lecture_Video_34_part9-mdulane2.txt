are thinking way too hard. The heap has two functions: it has insert and it has removemin. yeah? yeah, removemin. removemin. removemin, etc. until you're done. remove the minimum, remove the next minimum, remove the next minimum. alright! this is a sorting algorithm. so, the -- and I'm gonna talk about the benefits -- the running time -- the benefits in just a minute. um, so the first thing is to... the first thing you wanna do with your data that came in unsorted -- so this is given an unsorted array -- first thing you wanna do is build a heap. mkay. now, if I remove the minimum, if I remove A, what am I gonna do with it? Where should I put it? in the front of some other array, right? build it up, that'll be fine. but you know what? I don't wanna use this space? so where is there room for A? yeah, look! if I remove A, if I pull A off, first thing I'm gonna do is swap up W, right? I'm gonna get rid of W so I can use it for plugging the hole. so guess what? I have room for A. so I'm gonna go ahead and put it here. okay? and then do that again, remove then B is gonna be here eventually, then remove the minimum. we have room and so B is gonna be here. okay? so this is do a repeated removemin... uh, keeping values in the structure.and then the last thing is you might want to reverse the order of the array if, if you wanted it to be an increasing order. so you might want to reverse if you -- depending on what sorted order you want. okay, and what's the running time of each of those steps? running time step one is O(n), we just showed it. we just -- well, haha, almost showed it. repeated removemin, darn it. this one isn't better than nlogn. this one is, you know, you may have to -- lots of data may have to go pretty far. and then to reverse the array is again O(n). so the whole running time is O(nlogn). and the answer to why did we need another is that this one is an in-place sort. with worst case nlogn, whereas quicksort doesn't get you -- uh -- worst-case nlogn. okay, it does it in place, but not worst-case nlogn. okay, alright, I have one last thing before you go 'cause it's fun. we'll -- uh -- why did I choose this picture for our closing thought? it's a fun picture, right. but why is it the picture for today? when you're together with your friends, not at the semi-formal, and you decide to make -- and you decide to make a human pyramid, who goes on top? the lightest person, right? who's on the next layer? the next-lightest. so this is like a physical manifestation of a heap. there you go, it's not quite right though, we'll talk about it next time. alright, bye. what's up? I decrement size, but I'm not freeing the memory, so -- um -- what I'm doing by decrementing size is kind of moving that wall over. so that I don't -- in fact -- that, that, that means that space is available to me. yeah. yup. has a child, it has this code. oh, it has that, oh yeah, you're right, you're totally right. it's less than or equal to, right? yeah. yeah, oh, is it, okay. yes, there. okay. uh huh. about what? oh yeah. yeah. it's like. okay. so I can say less than or equal to. logn. okay, excellent, okay. thank you. that was exactly what I was gonna untangle.