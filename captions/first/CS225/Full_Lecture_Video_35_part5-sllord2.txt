There it is.  Right?  It's right there, I see it.  What I really mean by Find(4) in this context is tell me what it's equivalence class is.  Tell me some representative of the set in which it resides.  So this is very different than find from the past, right? In the past, when we did find, we pointed right to it or returned it's key.  We're gonna do something different here.  In this case, you're going to return you're going to return a representative from the set containing 0, 1, 4, 8 any one of them is fine.  Okay?  Any one of them is fine.  Feels very ill-defined at this moment.  What must be true is if two things are in the same set they must return the same representative.  So, I don't care which one of these you use to represent this set, but what I want to be sure of is if two things are in the same set, it will tell you.  You will get a true because a representative is the same.  Okay, was there a question?  I could return 4, yep.  But, when I do Find(8) I can't return 8.  So, sure I can return 4 but that means I gotta know that when I know where 8 is that it's representative is 4.  So, the question is what if you have a 12 and it belongs to the blue and green?  It cannot.  12 cannot be an element of two different equivalence classes.  Equivalence classes partition the set.  There is no intersection.  Intersections between every pair of sets are disjoint, they are empty.  That cannot be.  Here is an example of typical use of this structure.  If it's not the case that 7 and 2 are in the same set, if 7 and 2 are in different sets, take the union of the sets represented by the find of 7 and the find of 2.  So take the union of these two sets.  Find(7) is going to give us some representative of that set.  Find(2) is going to give us some representative of that set.  It cannot be the same because these are disjoint sets.  And, so, we're going to, as a result, the then is going to be to take the union of these things.  Now we're going to assume that union operates on representatives.  So, assume that union operates on a rep.  Here's a little bit of a more formal description of the abstract data type.  Each set has a representative.  We're going to maintain a collection of disjoint sets.  In this example here we have three of them. Each set has some representative member, we're not gonna try and prescribe who that is, we're gonna let that just kind of flow out of the application somehow. And we need to be able to support the following functions.  We're gonna need to make a set from a particular key. We're going to need to be able to take the union of two things where these things are representatives.  And then find will return a representative.