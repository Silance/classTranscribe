yes. exactly, exactly. yeah, remember that this is a one based array, right, like that, starting the root at one gained us the efficiency of being able to use two cIndex, two times the index as our last child. that's in last lecture. ok. alright any other questions about... OH! I know. So. this min child. actually when i wrote this code. i think i remember spending the very most time debugging this part of the code. and the reason for that is because... notice that i don't deal with the case, at all, that it has only one child. right, i don't deal with that. that one strange incident. one strange case in a complete tree where there actually aren't even two children. i don't deal with that here, at all. i only deal with it in this function. so this function, minChild, actually hides this test to see if there are even are two children, and in either case, if there are only one child it returns it, if there are two it returns the minimum of the two. ok. alright and because of that little ugliness, i shoved it into the helper function. alright, any other questions about this code? what questions do you think i'm going to ask you? i've just shown you some code, what do you think, i'm going to ask you? exactly every good. what the running time of this, we've got the running time, we completely understand how it works. whats the running time of this thing? of removing something from a heap? logn, log n, and please justify that. the running time is big o of logn, O(Logn), because, that is the height of a complete tree. it happens to also be a lower bond. ok, any questions about that? ok. so, i love this discussion because, um, oops, wow. I love this discussion because our original goal here was to implement priority queue. our goal was to implement priority queues with the assumption that that abstract data type would some how be useful to us. ok. and we proposed a whole bunch of implementation. and this last one, that we'll actually compare more carefully to the other ones, a little bit later. this last one is a structure that is beautiful in it's own right called a heap. but a heap really has, you know we a discussion about implementing this implementation, right. and in the end the, uh, the heap was... the discussion about the heap was "well should we implement is using pointer or as an array." and we decided it should be clever use of an array. and this notion that an abstract data type can actually lead to this sort of unfolding discussion of implementation in incre... decreasing abstraction more specificity is fascination to me. more over, there are tons of structures and algorithms for which priority queues are an extremely important, um, element. so for example  the event queue in every single video game that ever exists. so this an event queue. uses a priority queue. it which one need to come next. it's the. it is prioritized by time. even if all the events were created at the same time it can be thrown into a priority queue so that the next one with respect to time could be handled. um. another application. i'll bet you won't be surprise that original systems that allocated memory, dynamic memory, used a priority queue, right. implemented as a heap, yes. i don't know if they put the priority queue level. but that, i bet they did. so memory allocation... where in this instance. the size of the block of memory to be used typically was, in very early implementation, when they were just doing things, um, sort of in an add... without a lot of resources. when they were just developing these algorithms. that memory allocation was based on how much memory a block of memory had. that size of the block. oh my gosh, english, speak english. ok, so the priority was the size the block there of memory. ok, another one is, oh your to do list. right. what key do you use for your todo list?