On a tree...and this one is a characterization...of a tree...that uses that measurement. Okay? So, the...um...the vocabulary is the same, but there's a subtle difference in their application. Alright, so we say that a tree is height balanced if...uhh..if it's an empty tree, an empty tree is height balanced. Umm...or if it's not empty, then, you know, the recursive - the recursive nature of this definition says that whatever is true for the entire tree must be true of the subtrees. And, I think, what you wanted me to write here is b=0, but I didn't. I wrote the absolute value of b is less than or equal to 1. So, rather than demanding...rather than demanding that a binary search tree be perfectly balanced, and all it's subtrees, we allow a little wishy-washyness, we allow a little bit of imbalance. And the question is whether that's a big sacrifice or whether it kinda gets us where we want. Uh, any questions about that before we go on? Okay, so...is the tree on the left, ignore the little trees, is the tree on the left height balanced? 

Okay...I'll say no it's not. It is not height balanced. Now, I want you to find me this sub-the subtree that is not balanced. The subtree rooted at...51, very good! So take a look at 51, at that node. And what you observe is that, you know, the height of the left subtree is 0 and the height of the right subtree is 2. You know, I don't ever really think about the heights of those trees. I kinda eyeball it and look at the difference in the levels. Oh, look! There is a subtree where the left and the right different by 2. So, hence, this tree is not height balanced. Okay? Alright...uh...let's see..So what we're going to do - what we're going to do moving forward is...um...take our earlier observation - take our earlier observation that we prefer mountains to sticks. And we're going to view the change - we're going to view it as an operation on the tree to go from a piece of a tree that looks like this to a piece of a tree that looks like this. Okay? And the piece of the tree that looks like this is going to be based on the observation that this example tree is out of balance. And, by doing some little operation on the very same data, we create a tree that is very nicely balanced, thank you very much. So now let's apply that thought - that impression - to this tree. Where is the stick in this tree? Where is the stick that we might want to change? Where is the string of nodes all of which play into what might be con- what is an imbalance. Why there it is! Okay? So starting at the tre- node that is out of balance, the lowest node in the tree that's out of balance, because it's possible that there was another node out of balance. But starting at the lowest node in the tree that's out of balance, we're going to observe that anything that looks like this...if we applied this magic operation and just changed that portion of the tree, we could actually change the structure of the tree in a way that...um...reduces the height. Okay? And we're going to talk about how to do that in just a second. Alright, any questions about that? No, there are no technical details. By the end of the next slide, you will know how to do all the pointer assignments necessary in a pointer based tree to make that happen. So, if it feels technically a little mysterious right now...that's perfectly fine. Okay, i have another question for you...um...How would we asses...How would we find 51 and determine that it was out of balance. What would be an algorithm - Just kind of a loose description of an algorithm - to figure out whether or not 51 is out of balance? Eww, that's a hard problem, right?