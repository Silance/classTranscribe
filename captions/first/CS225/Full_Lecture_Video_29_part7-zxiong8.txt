Good, if you had 6, then these would all still live in the same node. Alright, let's see... Let's see what's I'm gonna ask... Oh, why not 7? This leaf implies not 4; this structure implies not 6. Why not 7? Same reason but also, these are 2 small. Any node with only 2 keys that's less than you can have for 7. 7 will have to have the ceiling of 7/2 -- 4 children. So we need to have at least 4 children or 3 keys. So this is too small to be 7. I didn't look at the test, so I don't know if the instinct about this is good enough. Oh, how much detail we need to know about that definition. I think knowing that definition is reasonable. OK, here's B-tree search. Here's some code, represents B-tree search. I think it's kind of  pseudo-code. It assumes some functions we have been articulated. In particular, it assumes a discrete function. So that we have access to some functions that when given a particular child we can find it. Now we are looking inside of B-tree node which you can sort of think of as an array. For a particular key, inside the array, x were looking for a key. Now, take a look at this code. And suggest any sufficiency, you'll find something that bugs you about this code. ...Pseudocode, I should say. What's it doing there? What's that while loop's goal? I'm asking all of you, I'm in conversation with [who?\] but I'm asking all of you, what's that while loop's goal? [student answering] What's the efficient fashion. Look, we've made a big point, good job. So we have made a big deal about the fact that the keys in these nodes are ordered, right? You should never search through an ordered structure, especially an ordered array linearly. You should just use binary search, that's what you get for this. Here's the thing now. I don't care, and here's why. These are all.. each one of those is a super fast operation. They're super fast. These all happens in the CPU. The data is all sitting right there. It's this discrete that determines the running time of the algorithm. Very long running time.