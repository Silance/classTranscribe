And you go out, and you get the part containing 51, and you bring it back.  So, there is this big trip that happens from your conceptual notion of the AVL tree to the disk, and this is very slow.  And you bring the data back, and the comparison is quick, and we say "okay, we need this." And again, you know you go out, and you get this [vocalizing, ohh].  Ok, and then you say you need this, and you go out and you get it from another spot on your disk.  And finally you go out and you get it and you go, "Oh yay, 66, that took a long time."  Ok, so this is bad.  So shallow trees are basically imperative.  Because, they minimize the number of trips that you have to take to the disk.  Here's the other thing, here's the secret, here's the secret I didn't tell you: Back when I was over here, getting the key off the disk, over here, way over here, I didn't just pick up one key, what's transferred back is actually a block of data.  A whole block of data, ok that's the bandwidth of the interaction with your disk.  Now, it would be great if a lot of searching could happen in all of that.  So, we want a structure that has a shallow tree, and takes advantage of relevant data in the nodes, in a block.  So, my picture of what's really happening is you get a bunch of data from your disk, even if you're only interested in part of it.  Ok, any question about that?  Alright, I have something fun to show you.  This is a b tree, this is what we call a b tree, so I read about it a little bit,  I don't know what b tree stands for, but the speculation is that it stands for block, ok, because this is a one node, b tree.  Ok?  Now, in fact, it's the root of one.  Um, it corresponds to an entire block of data brought back.  Usually they have uh um a thousand keys in them.  We have only eight keys.  Um, and we'll describe what m is in just a minute.  So, what do you notice about those pieces of data?  They're in order, that's right!  So, and it's a node of a b tree, so a node of a b tree is a essentially a vector or an array of ordered keys, ok?  Um, and these are the principles:  Build a tree that uses one disk block per node, uh the nodes will have more than one key, and they key will be or the tree will be balanced and shallow. We'll start next time looking at an illustration of these, because they're really quite cool.