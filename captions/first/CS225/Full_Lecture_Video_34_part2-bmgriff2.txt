So, our keys are type T here, and we are basically going to grab the root of the tree for returning. So, this is the value that we are going to return. Then, we are going to replace that value at the root with the last value. In this case, that was 4 replaced by 11. Then, we are going to decrement the size effectively removing the last element from the tree, but we have kept it, so we didn't remove it, we just removed something. And then, heapifyDown from the root, and then return that minimum value. Any question about that? Is it okay? Alright, so now lets do heapifyDown from an index. Now, keep in mind that that index is the location of the key. So we are always going to be comparing our array at location index  to get the key values. So if cIndex has a child, what is has- oh- I'll ask that in a minute. For a minute, just assume that hasaChild just works. It will tell you true or false based on whether or not cIndex is a leaf. I could of put isALeaf there. If not isALeaf(cIndex), that would of been fine. It is just the opposite. Alright then, I am going to grab the index of the minimum child. Okay, so I am going to make this function deal with finding the minimum child. And we'll talk about why I did that in just a minute. And then if the location is okay- which way does this go? Which way does this go? If the thing we are heapifyingDown is... what inequality goes here? Greater than the minimum child than we should shove it down. Right? Good. Yes, if items[cIndex] is greater than the minimum child, then we should swap the values. So we should swap items[cIndex] with items[minChild]. Yeah, what? Alright, indexMin items[minChildIndex]. Ahh! Swap those two, and then heapifyDown on minChildIndex. Okay, does this seem okay? Okay, we used two helper functions to make this code look beautiful. Beautiful code at all costs and I am not actually going to expand this, but I am going to know what that code looks like. How am I going to check if cIndex has a child? Yes, Ian? Excellent, that's excellent. What is 2 times the current index? It is where the left child would be if it existed. So if that value is greater than the total number that we have, greater than size, there is no left child. And that is all that code is, so this is 2 times cIndex - I should be able to spell that- greater than size. Or you could say- no you shouldn't say left child. You should say 2 times cIndex greater than size. Yeah?