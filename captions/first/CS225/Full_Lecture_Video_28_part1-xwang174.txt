Any question about that? So, if we forget to say it, we will always mean the least bigO possible. You could probably recognize that I could put a 2^n and that will hold in almost everything we do. Alright let's get started. I'm going to draw last time's picture very quickly. I tried to do it in powerpoint and I'm not a powerpoint user. So I failed. So here is running time of our function. Here is the running time of our algorithm. This is the function reflect it. We don't necessarily know how it's characterized. We don't know it has to do with all kinds of things that are not necessary. We don't know necessarily what kind of function it looks like. But we have a feeling that there is this other function somewhere that we can use to reflect the running time of our function. We also don't know what this function looks like. It might look like something like that. In fact this one is what we do know what it looks like. In the case of this particular example, we are going to argue that the running time is log in the size of the data. The reason we suspect that's appropriate running time is because of the structure of our tree. Because the heights of the balanced binary trees. We didn't just pull this out of the air. It was sort of a good guess based on the way our tree split our data in half. In fact, for regular binary trees we couldn't say this. We couldn't say logn here for regular binary search trees. We couldn't guess logn. We couldn't prove it. But in the definition here, we allow for some. We allow for some function, whatever it is, to be pushed up by some constant scale factor. Positive scale factor whose intention is to push that function up for a little bit. We also allow for some muss at the start. I'm going to draw some c times g of n in kind of exaggerate because there is something I want to illustrate very concretely on this picture. So I'm going to draw the c times g of n sort of like this. So this is c times g of n. Maybe I have g of n drawn poorly. Doesn't matter much. OK. So now is f of n greater than c times g of n? Sorry, is f of n greater than c times g of n? Like we want in this inequality is that f of n less than c times g of n. Sometimes it's the right answer. Sometimes it's forever less than eventually forever less than... yes. So we have a bound here right? Here. Beyond which f of n is forever less than c times g of n. If I to label this right here, this on the x axis, what would it be? That's right, that's k. Any questions about that? I'm doing this carefully here. I'm actually think this should be done carefully in 173 I don't know if it is or not. I'm doing it here carefully because we are going to it turns out that making this less than or equal to argument isa pain in the neck. OK. There is all kinds of like, potential for all rounding and floors and ceiling and I don't want to deal with that kind of stuff. I don't know about you. So what we are going to do instead is to invert the argument completely. So we are going to completely invert this picture. I haven't practiced it for a while. It has been four years since I drawn this picture. So let's see if I can do it. So where is f of n go now? In the inverted picture. It goes like this, right? Is that what f of n looks like? g of n as I have drawn here. It goes a little bit farther from the axis and stays forever on the back side of the f of n. So g of n looks like this. Right? And c times g of n now looks like this. Yes? Did I do it right?