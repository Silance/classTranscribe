we need to be able to deal with that . OK , so let me explain that last formula a little bit . If your key space is about the size of your table, then you can take elements from your key space and just give give them a value in your table. Sometimes when I do this, like programming in python, I'm gonna want to put data in an array. I will append an index value or some kind of identifier on the front of my data.  Because I know I can, the table will be big enough, I'm kind of finding a hacky way of identifying a key with a particular location in the table. This is a perfectly reasonable thing to do. It your key space is about the same size of your table. if all the data you could possibly have will fit in your table. But here's what hashing generally mean. Usually, we will have a huge key space. OK, some huge mathematical description of what key could be. And we are gonna draw some sample from that key space. We'll draw some reasonably size sample from that key space. And what our hash function has to do is take this data and map it to some cell locations in the table. and the table has to be big enough to hold this subset. But here is the thing. A general hash table should work independent of what subset is drawn from the key space. So it may be the case that in stead of that cycle, we draw a sample from a key space that looks like this, and the has function needs to map those nicely into our table. Put them somewhere else, OKï¼ŸNow what we want to avoid is what we hope to avoid is some sample from our key space. Some sample from our key space, where all of the keys map to the same location, that would be bad. Not using our table effectively, and we wouldn't really know where keys were really, Because they'd all be the same place. Any question about that? So this is again more sort of general how to think about hashing. This is a much harder problem. Finding a general purpose hash function. And it's where we're gonna start next time. 