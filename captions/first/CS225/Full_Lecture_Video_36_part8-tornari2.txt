In the example s(i) will be 10.  That's right.  So the parent of node i, the parent of the current node will point to 10 in the end, from the previous example. Ok?  Uh huh? Yup, because the find of ... so for,  for's parent is s(4), right?  And 10 is going to be passed all the way back.  Right?  It returns, the way that returns works is to return the right hand of that assignment statement because remember thats how assignment statements work right?  They eventually return the value that you can chain things together. Ok, does that make sense?  Ok, its a [gibberish] its a recursion, if nothing else its the recursion fairy right?  It comes in and says well what is the find of the parent ?  Find of the parent is the root, right, thats what we are going for.  The find of s(i) is the root.  I want to take that root and make it my current parent.  Current node's parent.  Ok?  Any questions about it? Do you want to talk about it more?  I hate unrolling recursion though? Yea?  ... Yea you can because the assignment is just a recursion call.  The actual syntax of this you can change it.  If you want, you can say [gibberish] s(i) equals, s(i) the find return of s(i) if you want.. ok.  Any other questions about it?  But you don't have to because the assignment returns a value.  You good?  Excuse me?  Yes, it will always return the right side.  That's how assignment operators work!  You know this already because we wrote an assignment operator and it had a return value.  Right?  This is it.  This is one of the reasons why.  Ok!  You good?  This is ok?  You might be happier with it if I but parentheses here, maybe?  Would that make you happier.  Ok....  Alright, any other questions about it?  Is it good?  Ok, so what's the running time of this function?  What's the running of this one?  Constant time, same function.  Now we need to talk about the running time of that one.  It is still going to be proportional to the height of the tree.  Now, what do you hope is the result of this.  You hope it is constant.  Right?  You hope to be able to say that there is a constant that bounds the height of these trees.  Oh, such a sad, sad day. We can't quite say that.  What we can say depends on this new function called an integrated log.  So this is an iterated log.  Ok, log* (n).  Ok, so how does log*(n) work?  The log*(n), it basically just counts the number of times you can take a log of a number.  Ok, the number of times you can take the log. Now, how many times can you take a log of ... uhhhhh... this?  How many times can you take a log of this?  How many times can you take log base 10 of 15476.  How many times can you take the log base 10 of that before it bottoms out?  You want to say four times, right? No, no, no.  You take the log once and you get five ish, right?  You take the log once and you get 5.  What is the log base 10 of 5.  It has already bottomed out.  Thats what we mean by bottomed out.  So its the number of times you can take the log not the log of it.  Ok?  Alright, ok?  So here is an example.  Here is a more careful example, how big is that number?