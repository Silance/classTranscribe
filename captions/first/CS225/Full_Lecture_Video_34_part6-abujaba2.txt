connecting! haha cost us a minute. alright so this is n log n and the argument goes did we do it ? no i didn't fix it but the argument goes if you sort the data in an array then every increasing subsequence of indices will be an increasing subsequence of keys, right ? in every if the array is sorted then every increasing subsequence of keys in that array are going to be increasing so the ones that had to be pads those will be fine so that is the argument that a sorted array is a heap not particularly a deep argument. okay this one works for sure because it is just repeatedly inserting the things in the structure. we could do this a little bit differently but i just wrote it so just it is a quick code. we can call insert instead but it took a little bit more took another line of code and i didn't want to use it. okay so we are going to user heapify up from you know i am admitting that the root actually is already a heap and this one is big oh of n log n and we are not actually going to prove. oh oh. big oh of n log n and we are not going to prove that here. now this one on the other hand is what we just talk about before it takes this one and finds its parent and argues that it is the first one that won't that maybe might not be a heap so it takes the parent of this one and calls heapify down from all of the other vertices, okay ? in that for loop. any questions about this. is it okay ? alright. now the speculation that this is big oh of n. big ohhh of n. mmmmmm. i don't think i am connected. alright that the speculation that that one is big oh of n. now let me just recover here. ohhhhhh. mmmmm. weird. i don't know. i don't know what state things are in. i bet that i can right now. n log n here. this one is big oh of n log n. okay okay. yeah i know weird. alright but i think we are good now. it is really like a ghost. alright any questions about it. okay. that is our speculation. don't ! what ? yes it is friday the 13th incase if you haven't noticed that believe me i have noticed that alright. so here is what we wanna know here is what we wanna know we want to know the running time of build heap that the algorithm we just talked about on an array of size n and we are going to speculate that this upper bounded by big oh of n, so when i say upper bound means less than or equal to and it is consistent of using big oh because big oh is a less than or equal to okay ? so lower bound goes with omega upper bound goes with big oh. alright now the problem is that running time is a little bit well, the running time is proportional to bunch of paths and those paths links are like height or levels in the structure so we are gonna change instead of talking about specifically running we are going to talk about path links or the amount of work that is done in one call to heapify down okay ? alright hmm we are gonna let's see so the running time is proportionally to the sum of the heights of all of the nodes okay ? now we've changed this right ? because i can make this argument about h. h the height is really important here, so we are going to go ahead and pretend that our friends are interested in knowing about the running time with respect to h and then we are going to change h to n in the end because really nobody wants to hear about your stupid running time in terms of h they want to hear about it in terms of n but it is easy to compute in terms of h. easy ! easy ! aha ! alright !