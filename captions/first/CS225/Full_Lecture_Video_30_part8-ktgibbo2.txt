Alright so there's a dice roll, it's kind of random right? Here's how we're going to transform any dice roll. We're going to give yourselves bins for each number. We're going to give ourselves bins for each number, so here are all the ones, here are all the twos, here are all the threes, here are all the fours, fives, and sixes. K, and then we're going to take the five dice and put them into one of the bins. So in this example, we're going to have two dice in the ones, uh, one die in the threes, and two dice in the sixes. OK? now, I assert that if I give you an encoding like this, you can tell me what the dice roll is, and if I give you any dice roll, you can give me the encoding for it, Yes? and so counting the number of encodings is the same as counting the number of dice rolls, Yes? just nod your head if you buy that. 
Alright, now how do we count the encodings? well how many different things are there to lay out in an encoding like this? There are... five dice and five divisions between dice, right? So there are ten positions in the encoding, half of them are going to be divisions between, and half of them are going to be dice. So how many different ways are there of creating such an arrangement? Ten choose five, very good. So it's ten choose five, k, is the size of the key space. Any question about that? I needed to do it quickly.
So for example, I'm going to lay down a random one of these that contains five divisions and five dice. You want this one to be a division or a die? Yah ok, division. Die die division division division die division die. That corresponds to zero ones, two twos, zero threes, zero fours, one five, and two sixes. That make sense? See that? K. You're not going to be tested on this, this is for fun. 
So how big is this number, ten choose five? Ten times nine times eight times seven times six, you know, divided by a little bit but not by a lot, so about ten to the third, thank you. It's around a thousand, I'm guessing. Ok, ten choose five is only two hundred fifty two? Ok fine. Alright, so what we just figured out is that there are two hundred fifty two different dice rolls we can have, how many different mappings are there? How many different targets are there that they map to? Ten, right? you can have ten different values, so actually I have a slide for this, in this case, your key space is huge. Your key space is large relative to your table size. Alright, relative to, or the range of your hash table. So there must be collisions, there must be a lack of one-to-onedness. 
Alright, so let's talk about this, let's go backwards now. So what's a hash table? Let's go way back, let's forget pedals around the rows, this was all meant to give you a domain in which to think, but now let's go way back to the definition of a hash table. We need to create a hash table. Here's what we're going to need. We're going to need an array; that's kind of obvious. That's the table where in an implementation level, we're actually going to be storing our data. We need some hash function. You've seen a perfect one, a super-good one, and you've seen a bad one, and what we know right now is that this idea of a bijection is a good one, k? Mathematicians still to this day spend time thinking about good hash functions. Creating a good hash function is not a solved problem. So we're going to be using hash functions that other people create, largely. And then finally, we're going to need what we're going to call a collision a collision resolution strategy, and this is simply a true confession that most hash functions will not be one-to-one. so what do you do if two things do map to the same cell? Hash functions are not generally one-to-one. 