ok what might described was that oops please let me write on my screen what might described was that 36 would be swapped in place of 35 and the order of the values would not change. So we have this small local set of data, if I wrote in all the data in the tree in order it would have look like this: 23, 35,36, 54, 74 etc. so if i've written down all the keys in the tree. now our goal was to remove 35, what we're saying is ok go ahead to remove 35 we can do that. if we either sort of let 23 or 36 take its place. now we have special names for these things. the name we have for 23 is the in-order predecessor and the name we have for 36 is the in-order successor, and these are in the slides for last time. you can't read this I'm sure coz i can't. if you look at the..if you use this output and you go look at the menu, you can choose whether or not you want to do a removal using the in-order predecessor or in-order successor. so this is recognized at the designed decision that you are going to make. now I made the design decision to use in-order predecessor because the text book that I used to use used in-order predecessor. Text books on data structure are well evenly split between IOP and IOS. But both of them are kind of wrong.Because the consequence of always using one or the other if you're doing a lot of removal is that you get a tree that's kind of lopsided if removal always happen from the left then the tree can be heavier in general things that're on the right. so you end up inducing a imbalance in the structure just by virtue of the mechanism you use for removal. so real algorithms to do this would probably swap back and forth between in-order predecessor and in-order successor. maybe, maybe. some definition of balance may come into play. might be the height of the other sub-trees. and there're other matrix on trees that you can use to access the size of a sub-tree. balance almost always means that the size of the sub-tree are approximately the same. the question is how the size defined. is it height, is it number of nodes , is it some other metric on the structure of the tree. and that's for discussion. ....ok any question about all that. so i just wanna to remind you that bad applet exist i think i find it [procecularly] useful. will use it again. ok um running time so we're talking about implementing dictionary using binary search trees, so far any time we talk about implementation, we're responsible for arguing about the efficiency of that design choice that implementation choice,  now this moment the only thing we have to argue the running times of these algorithms are ,, we know that they all used the height of the tree, that they all traverse the height of the tree, or walk down in the worse case the height of the tree going to determine the running time. alright and then traversal is of course just by every reminder if bigO of n the amount of  data in the structure. ok so let's see...i wonder know this is just a little bit of practice i wanna know what this tree looks like. so really quickly declare myT to be a binary search tree, go ahead and on paper as quickly as you can implement that sequence of insert. will you do your on my tabletï¼Ÿ it doesn't matter you can make as many mistakes as you want. so did everybody do this? just build the tree very quickly, insert into the binary trees several times.