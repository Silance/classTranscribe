AVL tree,B tree yeah sort of but if our data is so big it doesn't fit in memory it is not going to fit in memory here either.Mostly AVl trees maybe a linked list but those have been bad for a long time.So primarily it replaces an AVL tree. I need to go backwards and reemphasize something.I need to go back here.What is the running time of finding something in a hash table?If alpha is constant,what are these running times? They are constant, that's right.When somebody tells you hash tables have constant time access it's because that load factor is held constant in this strategy.Okay so, this re-sizing strategy is used to hold alpha constant.Which means find is constant,insert is constant.
And those are probabilistic results so those are average results.Yeah? Sure. No it calling re-hashing,yeah.Seperate chaining is open hashing where you just hang your data out,we talked about it last time.Okay it is the first collision resolution strategy.Alright lets do a lecture like this today okay.Yeah Mike, umm you are not going to because your table is going to be fairly empty,just over half full or so.Yup.Yes.We are gonna put an upper bound on alpha, alpha is never gonna be worse than 2/3 so the functions are never gonna be worse than whatever that is.What else? the absolute worst case is just ignored.If I were implementing a hash table from scratch I would put fault tolerance in it right? Like use two different hash functions and take the better of them say for example.
So the question is if alpha is one one less than tablesize/N, if I still take N-1/n and I keep it there that running time is gonna be constant but really bad. So I am still gonna keep alpha fixed relative to the table size so there is no n in the expressions for running time coz alpha is gonna be constant even if it N-1/n close to 1. I am gonna control alpha.I owe you guys alright. I have a puzzle for you. Lets go to a puzzle. So there is a constraint when we use AVL trees, there is a constraint on key space that does not exist for hash table and I am going to constraint on the keyspace for any BST in our case AVL tree that does not affect hashing. To evoke the idea I am going to do this. And ask you what did I do at every vertex here in an AVL tree. What do you do at every opportunity of branching in an AVL tree, what do you do. You decide it is bigger or smaller, you make a comparison. AVL trees require comparable keys.That constraint doesn't apply to hash tables.So AVL trees, BST in general, require comparable keys.


