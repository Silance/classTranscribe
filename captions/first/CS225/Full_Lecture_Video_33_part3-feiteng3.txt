Ok. How long does it take to insert into an unsorted list. Unsorted list. I just want to put values in. How much time should that take? Oh constant time. Look at that. There's a mistake already. Constant time. Good. How about removeMin? Is o(n) correct? I want to find in a unsorted array the minimum value. Thats fine right? Ok. o(n) is correct. I would have to go on a hunt through the linear, a collection of data looking for the minimum. Ok. Fine. How about for a linked list. If we implemented this functionality insert and removeMin using a singly linked list. How much time would it take to insert? Constant. I would put the new one back here right? No. No reason to do so. It's all unsorted. So when you insert, you would insert at the front. You want to do that in constant time. Or if you have a tail pointer you can do it at the rear. Ok, fine. How about removeMin? Still o(n). We would have to go searching for it. Ok fine. Let's suppose we decide we can fix this. We will fix it by using a sorted array. In that case, how long does it take to do a insertion into a sorted array? Two, three, five, eight, thirteen, twenty one. And I want to insert eleven. How much time does that take? Logn right? How come its logn? Why are we thinking logn? Binary search. Very good. So you observe the opportunity for binary search. So we use binary search to determine that eleven goes here, but we have to sit the data. So this isn't true. Oh gosh. I swore when I came to school today. Today would be a better lecture. Of course then Mondays. That's a low bar. Alright. How about for a linked list, a sorted linked list? Can you do binary search? No. Can't do binary search in this case. It's o(n) to find. Ok so this is the moment where. This is for find. This is for shift. How about removeMin? Are those correct? They are constant in both cases. Is this correct? Could it be correct if I have put those differently? Ok. So I should have done twenty one, thirteen and eight, five, three. And then it would be constant time. Cause we always remove from the end of the trunk of data. Ok. How about for a singly linked list? Is it constant time to remove the minimum?  Yes. If you keep the minimum where? At the head of the list. Right? What if you keep the minimum at the tail and you had a tail pointer. So I'm gonna keep the minimum here and have a tail pointer. What do you think? Removing that guy. No. Because I can get to it in constant time but resetting this tail pointer requires traversal of this structure. Ok. Everybody good? Ok. So take a look at this nasty table. And it looks like there's some trade off going on. Right? We got constant time for one of those function and liner time for the other function. What would be better than this? What would be better? Logn would be better especially if we are able to replace the linear time function with logn. Well. I'm not gonna tell you how good it gets. Instead I'm gonna switch gears so that's a reasonable goal. And the question is whether not we can do logn here in constant time. Just how good can we do. Using a different structure. Ok. Now. I want to leave this one hanging. Because I want to show you something completely new. This would be more fun to you. If you focus here instead of on your paper. Ok. Don't look. I know you wanna look. Right. But don't. Alright. So here's the new structure. What I want you to do is tell me everything you can about it. Tell me everything you can about it. Everything you think might be interesting. Everything you think characterizes it. 