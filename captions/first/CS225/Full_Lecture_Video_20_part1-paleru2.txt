Yeah eight and eleven right? Everything else has a child so eighteen has one child twenty has two children. Twenty is called the root node. It is the only node in the tree that does not have a parent. Every node has exactly one parent. now a little bit trivia. If there are four pieces of data in the tree, there will be five null pointers. If you think that's true, if you have one piece of data then you have two null pointers, then two pieces of data may have three null pointers because one of the null pointers get used up to point to the other thing, and adds two. So you always delete one null pointer and add two every time. If you have one two three four five, for the four pieces of data. The other thing that is really interesting is that all the leaf nodes we stick them all together it is called the frontier of the tree. In a binary tree, half of your data is going to be in there. So you can imagine if you want to do something with the tree. You're going to have to do something down to look around for the data and half of it is going to be far as possible as it can get from the root. This is not very far usually but that is something to think about. Now, try to image in your mind how to you're going to implement thing thing. You're at the console, you're going to open down the curser is blinking at you what are you going to type? Try to imagine that and you can look at your hand out. If there is something is there. There is a little type that should be class t, the slides are really forgiving compared to the complier. So this is just a standard we have a wrapper class. I am going to binary tree and inside of the wrapper class is going to be the node which contains the data. The wrapper class is going to handle the data and hold and keep a root pointer so that you know when we are oging to enter the data sturcture and the node class is where all these pretty diagrams come from. So how is this looking for you guys? Do you like this? Is it making sense? All good? Alright, now this is a recursive data structure so almost every function you write is going to be recursive. you could use a for loop or a while loop but it is not as natural. How do you guys feel about recursion, I am going to be thinking. You know what would be nice is to review this. I mean like no way i am sick of recursion because the only thing you need to know about recursion is to understand recursion. Alright, well lets talk baout it. pherhaps you want to do recursion. I know cinda has talked about it but I want to talk about it again because recursiion is the second most powerful concept in computer science. Abstraction. If you know abstraction you know recursion, you are a computer scientist. So, you don't even need a computer. It helps, but you don't relaly need one. Alright, so I want to talk about proof by in induction. How many of you are familiar with proof by induction. How many of you feel like yeah I got it and I am okay with it? How many of you fee like ahhh, i hope it is not on the test? Alright, So proof by induction. This is the wonderful thing about computer science. We have turned being lazy into an art form. We have tricked people into paying us dearly for it. So heres how it works, proof by induction. We call it p of n some property p we give it a name because i don't want to think of a specific one. It is something mabye it is integers, trees, doesn't matter. As long as you have some idea that there can be if you have some concept of a smaller version might look like. If you're an integer, you can follow it easier right? For tree, you have this tree, how can you make a smaller tree? you go to left or right side. you have a smaller tree. Now this is really important that you can do this. Now the other thing you need is the idea is that you have the smallest version of a tree. The smallest tree is a leaf or maybe null. Depending on how you think about it. So what you do with induction is you say that for n =  1 or whatever the smallest thing is you prove that your property is true for that and that is usually really easy almost trivial. Induction what you do is you want to prove p of n. In some cases you might want to prove p of n+1 doesn't matter. Turns our they do the same. Now you just assume that p of n is true. You pretend that some grad student did all the work and you come back and take all their credit. So ah don't tell the grad student that you did that. So what do you do with this? You use this struct to prove this fact. You say if this is true, then with a little bit more work, you can prove that this is true as well. You perfect n. 