Oh, okay, so it's working alright. Now I'm gonna plug it in because I like it. Now I"m gonna do 40 again, sorry. Delete. Boink. Oh okay. So that was fine. And then I'm gonna insert 76. I'm gonna make it look like it was before. Oh no. Don't mess with me. 76. Insert. boink. boink. boink. boink. And now, we're gonna insert 85. didn't expect that part to take five minutes. Okay ready? ready? are you sure you're ready? Okay we're okay, oh oh woah. They do it a lot faster than we do. Okay. Let's try...so now what I want is something you could insert, let's take 85 out okay? Sorry I'm keeping it in for one time. Deleting 85. Nothing's out of balance. Perfectly fine. Now I want to know a key some key that when inserted will result in a right rotation. 62 would do it. Anything bigger than 36 or less than 75 right? anything in 75's left subtree would result in a right rotation is that true? Yes? and anything in 75's left subtree can contain keys between 35 and 75. So, Somebody raise their hand you get to speak here. Yeah what number you want? 45. Okay. 45. And inserting boink boink boink boink. Oh that's not out of balance, that's not out..ohh. uh oh. right rotation. what happens if i insert 17? Nothing special right? 17 finding the spot for 17 and checking to make sure that everything's okay on the way up. yeah Mike? Oh, going up is sort of like yelling out a value after you've processed the rest of the tree in a post order traversal. So I am actually doing this post order after the recursive call is made. and when you look at the code I'll be sure to point that out. So all of this, all of the valuation assumes the insert has happened. okay. let's I want now a key that will result in a double right rotation. In a right rotation, but a double one. a double right rotation. I believe there's only one key that will result in a double right rotation. and it's a power of two. 




