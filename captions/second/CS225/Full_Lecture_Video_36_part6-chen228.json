[{"text":"Um, but it also guarantees that same running time.","width":307},{"text":"Okay, so now, let's write the code that does this.","width":233},{"text":"Let's write the code that does this.","width":170},{"text":"Oh, we're not gonna prove the log n here.","width":154},{"text":"We just, we're gonna move right past it.","width":177},{"text":"We're gonna be satisfied at this moment of having log n.","width":211},{"text":"But we're not gonna take the time to prove it because we're gonna do better.","width":409},{"text":"Alright, find has not changed.","width":177},{"text":"So the code for find didn't change at all.","width":299},{"text":"But the running time of find is gonna change.","width":206},{"text":"We didn't even touch it.","width":99},{"text":"And its running time is going to change.","width":172},{"text":"Alright, so here is UnionBySize.","width":235},{"text":"UnionByHeight could be done similarly.","width":191},{"text":"I don't even think we ever ask you to do it.","width":110},{"text":"I think we always ask you to do UnionBySize.","width":188},{"text":"Notice that the new size is the sum of the values at the roots, just like we suspected might be the case.","width":460},{"text":"Umm, if, so we got this helper function isBigger that merely, you know, takes the negative of the value in the root, right?","width":502},{"text":"And compares them.","width":124},{"text":"But I gotta a little bit lost in the equalities there, so I want to test that separately and make sure it did what I thought.","width":697},{"text":"So let's see.","width":87},{"text":"This is, this means root1's tree has more nodes than root2's.","width":1218},{"text":"Okay?","width":83},{"text":"Alright, so if root1 is bigger, then we're gonna point root2 to root1.","width":437},{"text":"And then root1 gets the new size.","width":191},{"text":"Okay?","width":50},{"text":"Any question about that?","width":68},{"text":"Otherwise, we'll do the opposite.","width":78},{"text":"Any question about it?","width":125},{"text":"Okay, what's the running time of that code?","width":661},{"text":"Yeah, it's constant time.","width":94},{"text":"Good.","width":89},{"text":"Because there's no traversing going on.","width":276},{"text":"There is no, there is nothing about the size that any of these structures that affect the running time here, right?","width":390},{"text":"We can look up the sizes, are just array look-ups.","width":347},{"text":"The comparison is a constant time thing, the condition evaluation.","width":271},{"text":"Then we just got a couple of assignments.","width":140},{"text":"So this is still a constant time operation.","width":239},{"text":"But it has the effect of maintaining the trees as short trees.","width":457},{"text":"So now we can say that find is O(log n).","width":363},{"text":"Do you remember what was the best we had before we started using these up trees?","width":527},{"text":"The naive implementations of, I guess it was probably, umm, using an array?","width":558},{"text":"Do you remember what it was for using an array?","width":342},{"text":"It was constant time for find, but it was O(n) for taking the union, okay?","width":458},{"text":"So this is using an array.","width":153},{"text":"And you can go back.","width":449},{"text":"Using an array naively I should say.","width":169},{"text":"You can go back and review that, okay?","width":182},{"text":"So do you like this better?","width":313},{"text":"Kinda depends which one you do most often, right?","width":231},{"text":"And in fact in a sequence of using this structure, you can only take unions so many times.","width":407},{"text":"So this doesn't feel quite satisfying to me yet.","width":461},{"text":"Okay?","width":41},{"text":"We shouldn't stop here.","width":381},{"text":"We should do one more thing.","width":349},{"text":"Let's suppose we do a find(4).","width":531}]