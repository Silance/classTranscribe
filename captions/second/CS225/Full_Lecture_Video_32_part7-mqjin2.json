[{"text":"So we run each of these through the new hash function and they may end up in a completely different location in the new array.","width":962},{"text":"But when we go looking for them, we know we can find them.","width":271},{"text":"Okay any question about that?","width":171},{"text":"Otherwise though its exactly parallel.","width":150},{"text":"We don't fill the array, we don't exactly double the table size, we don't copy the data, but we have analogous parallel things to do in each of those cases.","width":735},{"text":"That process is called rehashing.","width":679},{"text":"Twice the array size.","width":571},{"text":"So am I worried about having to find the first prime greater than twice the table size?","width":459},{"text":"No, we can find primes in a table really quickly.","width":308},{"text":"you can store a lot of primes for lookup, you dont have to compute them.","width":318},{"text":"Certainly enough to create an array of that size.","width":655},{"text":"So the question is where does the 2/3 come from and does it only strictly apply to linear probing and double hashing?","width":576},{"text":"It's the load factor that corresponds to probe based hashing strategies generally, however they are implemented.","width":720},{"text":"So probably its a double hashing, in general you'll let your table be 2/3 full.","width":533},{"text":"And it gives you sort of a feeling of what's going on behind the scenes when you use a hash map as well.","width":686},{"text":"So the question is, is there any way of escaping the fact that we are intentionally allocating memory that we aren't going to use.","width":944},{"text":"We admit going in that 1/3 of that space is not going to be used.","width":494},{"text":"I believe the answer to that is no.","width":155},{"text":"You have to allow for data to be mapped into those cells, otherwise you got a different problem.","width":489},{"text":"That's equivalent to having a full array, and then you got issues.","width":406},{"text":"So, where are we?","width":485},{"text":"We got these two collision resolution strategies, one of them just sort of hangs out the data, the other one uses probing to place it in the table.","width":720},{"text":"There are a gazillion others that you might use.","width":465},{"text":"For example, for separate chaining, instead of a chain, why not use another hash table, or why not use another AVL tree?","width":531},{"text":"Why not use something else instead of just a singly linked list.","width":328},{"text":"So the number of variability in that particular structure is astounding.","width":647},{"text":"So these are just sort of the basic ideas.","width":271},{"text":"Now, given those basic ideas, which one is better?","width":353},{"text":"The structure speed is way faster for probe based hashing.","width":338},{"text":"That is, if you can actually fit all your data in an array, that structure itself will be much faster.","width":1027},{"text":"But if your data is big, then you can't create an array that's very big using your memory effectively, and so you'll want to have the ability to hang your data off the structure.","width":829},{"text":"So if you have big records, then separate chaining is a better strategy.","width":481},{"text":"And of course this is a hugs simplification.","width":366},{"text":"What structures do hash tables replace for us?","width":293},{"text":"What do we use them to implement?","width":168},{"text":"Dictionaries.","width":51},{"text":"What did we use to implement dictionaries before?","width":342}]