[{"text":"So, our keys are type T here, and we are basically going to grab the root of the tree for returning.","width":760},{"text":"So, this is the value that we are going to return.","width":230},{"text":"Then, we are going to replace that value at the root with the last value.","width":492},{"text":"In this case, that was 4 replaced by 11.","width":158},{"text":"Then, we are going to decrement the size effectively removing the last element from the tree, but we have kept it, so we didn't remove it, we just removed something.","width":882},{"text":"And then, heapifyDown from the root, and then return that minimum value.","width":495},{"text":"Any question about that?","width":201},{"text":"Is it okay?","width":85},{"text":"Alright, so now lets do heapifyDown from an index.","width":309},{"text":"Now, keep in mind that that index is the location of the key.","width":303},{"text":"So we are always going to be comparing our array at location index to get the key values.","width":670},{"text":"So if cIndex has a child, what is has- oh- I'll ask that in a minute.","width":458},{"text":"For a minute, just assume that hasaChild just works.","width":240},{"text":"It will tell you true or false based on whether or not cIndex is a leaf.","width":391},{"text":"I could of put isALeaf there.","width":225},{"text":"If not isALeaf(cIndex), that would of been fine.","width":258},{"text":"It is just the opposite.","width":76},{"text":"Alright then, I am going to grab the index of the minimum child.","width":490},{"text":"Okay, so I am going to make this function deal with finding the minimum child.","width":402},{"text":"And we'll talk about why I did that in just a minute.","width":244},{"text":"And then if the location is okay- which way does this go?","width":405},{"text":"Which way does this go?","width":181},{"text":"If the thing we are heapifyingDown is...","width":210},{"text":"what inequality goes here?","width":264},{"text":"Greater than the minimum child than we should shove it down.","width":236},{"text":"Right?","width":229},{"text":"Good.","width":49},{"text":"Yes, if items[cIndex] is greater than the minimum child, then we should swap the values.","width":610},{"text":"So we should swap items[cIndex] with items[minChild].","width":810},{"text":"Yeah, what?","width":605},{"text":"Alright, indexMin items[minChildIndex].","width":341},{"text":"Ahh!","width":105},{"text":"Swap those two, and then heapifyDown on minChildIndex.","width":723},{"text":"Okay, does this seem okay?","width":865},{"text":"Okay, we used two helper functions to make this code look beautiful.","width":364},{"text":"Beautiful code at all costs and I am not actually going to expand this, but I am going to know what that code looks like.","width":437},{"text":"How am I going to check if cIndex has a child?","width":407},{"text":"Yes, Ian?","width":728},{"text":"Excellent, that's excellent.","width":154},{"text":"What is 2 times the current index?","width":116},{"text":"It is where the left child would be if it existed.","width":283},{"text":"So if that value is greater than the total number that we have, greater than size, there is no left child.","width":567},{"text":"And that is all that code is, so this is 2 times cIndex I should be able to spell that- greater than size.","width":1281},{"text":"Or you could say- no you shouldn't say left child.","width":253},{"text":"You should say 2 times cIndex greater than size.","width":295},{"text":"Yeah?","width":258}]