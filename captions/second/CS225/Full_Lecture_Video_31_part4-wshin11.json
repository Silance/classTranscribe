[{"text":"Um, if you're data is in a linked, if your data all maps to the same array cell, um, you have several different ways of handling it, which we'll talk about, all of which imply you have to search for your data within that cell.","width":1242},{"text":"Okay?","width":54},{"text":"And so, you might as well just to put 'em in a big bucket or a list, or whatever.","width":310},{"text":"Okay?","width":166},{"text":"Yes, right, that's right.","width":107},{"text":"Okay, so I want to rehash things again.","width":418},{"text":"Is the moment for the hash brown joke?","width":399},{"text":"I don't know, it's not right now.","width":205},{"text":"Okay, alright.","width":78},{"text":"Um, so I wanna revisit a couple things just to convince you that hashing is hard.","width":561},{"text":"So this time I drew the same picture but with the key space small in the first example.","width":472},{"text":"So, I wanna reinforce the idea that if you happen to know exactly what you're data is going to be, then by all means figure out a way of mapping your data into an array via a bijection.","width":1191},{"text":"Okay?","width":20},{"text":"That's on you.","width":101},{"text":"That's on you.","width":50},{"text":"You can do that, nobody's telling you, oh don't try to do that on your own.","width":249},{"text":"If your data is small enough, it's usually kind of a clever, you know, clever little puzzle to figure out ways of putting your data efficiently into a table.","width":696},{"text":"It's, um, it's figuring out identifiers for your keys that allow you to represent those keys using indices from an array.","width":827},{"text":"Alright, now why?","width":424},{"text":"nuuuuuung Okay.","width":744},{"text":"Uh, using indices as the representatives here.","width":404},{"text":"So, the punchline is if your key space is small, by all means, make your own bijection.","width":380},{"text":"Have fun, it's fun.","width":108},{"text":"Okay, on the other hand, if your key space is large or very general, that is you don't really even necessarily know what the key space looks like, which is the case for a lot of general purpose hash functions provided for you by a system, like C++'s hash map, then the puzzle becomes harder.","width":1754},{"text":"Because, every set of data that you choose from that hash function, it might not be a very big set of data, certainly it should fit in your table, right?","width":782},{"text":"Certainly should have memory to contain all of your data, but you cannot control what subset you get.","width":580},{"text":"So it might be the case that one subset will spread the data out nicely over the table, but, and maybe that will be the case for couple different subsets that happen to constitute your data for an application, but what you cannot guarantee based on arguments related to the pigeonhole principle is that no hash function can do well on all subsets.","width":1944},{"text":"There are just too many of them, too many possible subsets, especially of a large key space.","width":580},{"text":"You cannot guarantee good behavior from a, over all subsets...","width":1560},{"text":"from a general purpose "width":427}]