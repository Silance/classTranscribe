[{"text":"Apparently my head cold managed to confuse me so therefore I confused you","width":832},{"text":"and I gave you an incorrect delta to those examples to show you peterson's solution","width":534},{"text":"and what I did was incomplete","width":128},{"text":"this is peterson's solution","width":169},{"text":"it is in the book, the wiki book","width":229},{"text":"the wiki book is very new ","width":124},{"text":"I only started creating it last semester","width":192},{"text":"it is an experiment to say what would happen if I after every lecture I wrote some notes","width":360},{"text":"and rather than just put it in a pdf, actually make it a wiki page","width":197},{"text":"so the wiki book is yours to edit and to add to eventually we'll actually turn it into a hard copy and I'll charge eight hundred thousand dollars for each one","width":768},{"text":"right no I'm not going to give it to Peterson or any of those other vulture companies","width":305},{"text":"I'll eventually have a hard copy and basically sell it at a bit over cost","width":359},{"text":"but until we do that it is available on the web","width":192},{"text":"you too can edit it, you too can improve it","width":192},{"text":"and in fact i'll be talking partly about that on Friday","width":247},{"text":"there is a conference where we talk about educational technologies and I've got a talk about that","width":430},{"text":"and also about the linux in the browser project which you too can play with","width":344},{"text":"and it's all in the cs 241 home page and you too can help develop it if you wish","width":379},{"text":"so i have several people doing improvements on that project as part of their senior projects for example","width":452},{"text":"I also have another group adding subtitles, captions to lecture videos","width":446},{"text":"and are looking at crowdsourcing for that","width":128},{"text":"so lots of good stuff","width":111},{"text":"right so we've talked about that","width":192},{"text":"i'll tell you about some more news in a little bit","width":154},{"text":"right now let's turn our attention to today's little challenge here","width":569},{"text":"the first challenge is relatively easy","width":135},{"text":"but it's still nontrivial","width":128},{"text":"what we're going to do today is make a barrier","width":457},{"text":"so we talked about okay we can create all these threads","width":217},{"text":"and one way to program them would be to say create a whole lot of threads which work on a little problem and join on all of those threads and we wait for them to finish","width":538},{"text":"that's a perfectly reasonable and simple way to use threads","width":192},{"text":"but we can do better","width":119},{"text":"now that we know that we've got these primitives that can stop and wait","width":331},{"text":"we can make our threads wait for each other ","width":244},{"text":"so before going to a part b of an algorithm","width":259},{"text":"let's wait for everybody to finish part a","width":222},{"text":"so this is basically like before closing the door of an elevator and going down to the next part","width":298},{"text":"we want all of our other threads to finish","width":185},{"text":"so that's the idea of a barrier","width":128},{"text":"we can implement this using semaphores and we can say that we're going to look at using condition variables","width":576},{"text":"so remember what is a condition variable? it's nothing particularly special","width":198},{"text":"it just allows our threads to go into a meditative state and not use any cpu until we wake it up","width":400},{"text":"but it's called a condition variable because we've put this inside the loop that tests for some condition","width":712},{"text":"so let's look at our little story here and see what we can do here","width":519},{"text":"there we go","width":193},{"text":"right so I've set up a typical little problem here that hey I've got a lot of data here it is","width":616},{"text":"a big array","width":188},{"text":"it's in global memory so that makes life easy","width":187},{"text":"and I've got a calculation I want to do on it","width":256},{"text":"fortunately I know about threads so I'm going to split my big array up here into chunks","width":680},{"text":"and if I've got two hundred and fifty six blocks why don't I split it up into sixteen chunks","width":917},{"text":"for my oops I'm just looking down here if my x so this is now x and this is now y, nevermind","width":553},{"text":"so my x values are going to be rather than one thread going from zero to two hundred and fifty five","width":648},{"text":"I'm going to get each thread to work independently on a segment of this matrix","width":477},{"text":"alright so if we have a look at this ","width":192},{"text":"this is what we've got here","width":108},{"text":"in my main I'm going to fire off N threads","width":385},{"text":"okay so we'll define N to be say sixteen","width":410},{"text":"wouldn't it be nice to have a sixteen core processor","width":160},{"text":"well you too can right now either just spend a lot of money or wait three years and it'll be easy","width":539},{"text":"so it'll be cheap","width":51},{"text":"so then we'll start say 16 threads","width":271},{"text":"I want to ask each one of them to do a chunk of the work","width":165},{"text":"one sixteenth of the total amount of work","width":302},{"text":"okay so great we've called pthread_create","width":340},{"text":"what's the first argument we pass into pthread_create?","width":430},{"text":"yes we are actually going to pass in the address of that","width":253},{"text":"the address of where we want pthread_create to store the the thread identifier","width":297},{"text":"so how do I write that","width":105},{"text":"I could say ampersand okay here's my little array and I want the i one","width":477},{"text":"that's probably the most readable way of writing that","width":192},{"text":"an equivalent would be to say ids + i","width":438},{"text":"is that true? so think about that or test it","width":1066},{"text":"part of it becomes what's the size of this","width":154},{"text":"what happens when you add to it","width":193},{"text":"I'm not going to write that today","width":84},{"text":"I'm going to go with this","width":69},{"text":"right so we've got the address of where we want to store that identifier","width":385},{"text":"we don't need to set any special parameters for our pthread_create","width":174},{"text":"we're going to pass in this calc function that actually does all the work for us and finally we say (void*) i","width":361},{"text":"right so what are we doing here we're taking that little integer and we're turning it into a pointer","width":320},{"text":"you can that in C, remember it's just a bit pattern being converted into a similar bit pattern but we're saying that the type of it should be treated as a (void *) pointer","width":704},{"text":"why do I that, that's because that's the argument type","width":192},{"text":"and that will be okay provided we don't actually try to follow that pointer into memory","width":320},{"text":"remember it's just a value 0 1 2 3 4 5 6 7 8 9 10 11 12 13 15","width":320},{"text":"okay so at the end of here I'm going to wait for my threads to finish","width":355},{"text":"okay so here I'm just going to call pthread_join and this time pass in the value of my little identifiers","width":623},{"text":"and I don't actually care about the exit value","width":287},{"text":"otherwise I could have passed in a pointer to a void * to grab that","width":294},{"text":"and then I would write some code to print out the result which I don't care about","width":192},{"text":"so that's the outside of my algorithm, start all these threads, off you go, sixteen people start doing your work","width":389},{"text":"I'm going to give each one of you a unique number and then wait for them to all finish by calling pthread_join","width":585},{"text":"now the main part of this puzzle starts","width":172},{"text":"okay we're going to write our little calc program","width":300},{"text":"we know that our pthread functions take a void* and return a void*","width":827},{"text":"so I've got some pointer, I don't actually want to use that variable as a pointer though","width":275},{"text":"I just want to cast it back into an integer","width":466},{"text":"so no memory lookups were used in this casting ","width":221},{"text":"it simply says hey I know you treat me as a pointer, I lied I just want to treat it as an integer","width":384},{"text":"and I went through those hoops just to make the compiler happy","width":421},{"text":"and I'm confident that a void* pointer can hold the integer between zero and fifteen","width":294},{"text":"right so that's going to be my starting point","width":169},{"text":"my end point exclusive would just be the starting point plus sixteen","width":295},{"text":"so now in my little loop x can go form the start almost to the end and my y is going to go through all of the remaining 8192 entries","width":772},{"text":"right and then I do my calculation","width":128},{"text":"that's going to take a while","width":84},{"text":"now you might say really all sixteen threads are going to run at the same time so they are all going to finish at the same time","width":407},{"text":"well that's not quite true","width":222},{"text":"it could be that one of these threads starts very very late","width":312},{"text":"it could be another thread starts completely earlier ","width":128},{"text":"it depends on how the operating system decides to schedule these threads","width":221},{"text":"it could be that a cpu is temporarily stolen to do some other work","width":280},{"text":"like process an interrupt because you pressed something on the keyboard","width":179},{"text":"something arrived on the network","width":105},{"text":"something arrived from the disk","width":75},{"text":"so you're not guaranteed to have the CPU for 100% of the time","width":265},{"text":"so we're not quite sure when all of these threads are going to finish","width":204},{"text":"so that's where we come in now","width":85},{"text":"we're going to try and write some code in here so that we can make sure that we don't continue the second calculation until all sixteen threads have finished","width":798},{"text":"so what are you going to do","width":153},{"text":"how are we going to solve this?","width":199},{"text":"what do we need?","width":442},{"text":"I need some ideas","width":318},{"text":"we could potentially do this with a semaphore","width":175},{"text":"kind of, what other ways could we do this though?","width":556},{"text":"okay yes we need some sort of global count variable","width":146},{"text":"just keep track of how many threads are currently running","width":269},{"text":"we're not going to try and directly query these threads","width":222},{"text":"we'll just have some sort of global variable that all the threads can decrement to say oh yeah I finished","width":668},{"text":"okay so up here we'll have an int remain and we can set that equal to sixteen","width":587},{"text":"or N if we want to","width":498},{"text":"so when I actually finish my work, each thread will decrement remain","width":950},{"text":"now notice what I just said","width":44},{"text":"when each thread finishes, it is going to decrement remain","width":161},{"text":"at this point, alarm bells should go off","width":328},{"text":"okay very quiet ones inside your head","width":192},{"text":"because I've just said that more than one thread is touching a data structure","width":320},{"text":"so there's a potential race condition","width":143},{"text":"two threads might decide to decrement remain at the same time","width":185},{"text":"whoops we don't want that","width":78},{"text":"we want each thread to have exclusive access to this remain","width":260},{"text":"when it's actually manipulating that","width":105},{"text":"so how do we ensure that happens","width":152},{"text":"yes bring out your mutex lock","width":456},{"text":"maybe it looks like a giant padlock or anyways nevermind","width":347},{"text":"so yeah we'll call pthread_mutex_lock on our mutex","width":640},{"text":"okay so this takes a pointer to that data structure","width":326},{"text":"at this point alarm bells go off and say oh hey did I actually remember to initialize the mutex","width":334},{"text":"and the answer is yes yeah you did if you actually managed to write the correct function","width":382},{"text":"these are pthread_mutex_init is one way to initialize your mutex lock","width":308},{"text":"right so if we do a lock, we know that any other thread that comes in here has to wait","width":459},{"text":"it could be then that those other threads that have not yet finished","width":490},{"text":"in which case the thread that is running this code ","width":169},{"text":"we want it to go to sleep","width":77},{"text":"okay well let's suppose I didn't know about condition variables","width":356},{"text":"then I might say something like while remain is greater than zero","width":504},{"text":"do nothing","width":250},{"text":"wohahahahaha we laugh at that code wohaahaha","width":171},{"text":"why? because we do know about condition variables, but why else?","width":501},{"text":"yeah the first thread that gets in there is just going to spin around","width":448},{"text":"and round and round and round it goes","width":145},{"text":"the second thread when it finishes will attempt to lock the mutex","width":289},{"text":"are you prepared to wait? yes i'm prepared to wait","width":171},{"text":"right then the second thread that finishes will get stuck inside pthread_mutex_lock","width":248},{"text":"waiting to lock that mutex, but we can see from this code that that mutex lock is never unlocked","width":313},{"text":"the second, third, fourth and fifth and the remaining fifteen threads will never get past pthread_mutex_lock","width":455},{"text":"because that mutex lock is never unlocked wohahahah","width":232},{"text":"alright so how can we start fixing this code","width":322},{"text":"well here's what we are going to do","width":79},{"text":"rather than just having a busy loop where we continuously burn up CPU time","width":298},{"text":"we are going to call pthread_condition_wait","width":561},{"text":"and for that you pass in your condition variable and pass in a pointer to your mutex lock","width":494},{"text":"and every good systems programmer knows that is when your thread meditates","width":410},{"text":"it goes to sleep","width":255},{"text":"but before it goes to sleep what happens?","width":310},{"text":"what do you get inside here?","width":194},{"text":"for free, what's it do for you?","width":207},{"text":"hint, we have to pass in the pointer to the mutex","width":166},{"text":"why? because it's going to unlock that mutex for you","width":287},{"text":"and then go to sleep","width":192},{"text":"alright so one of our threads arrived here early and said \"look remain is still non zero, I'm just going to sit here and chillax\"","width":783},{"text":"yeah i'm not going to do anything, I'm just going to go into my meditative state","width":384},{"text":"the very last thread, the sixteenth thread that comes in says \"oh look remain is finally zero, I don't need to sleep, I can continue!\"","width":835},{"text":"so I'll unlock and off we go","width":298},{"text":"and the sixteenth thread to arrive will then do the second calculation","width":347},{"text":"right so that's not a very good barrier right?","width":436},{"text":"what do we do? we wait until the sixteenth sheep finally arrives that was enough weight to tip the balance and the sixteenth sheep could continue","width":576},{"text":"and all the others are left there waiting, sleeping, yes?","width":319},{"text":"we'd like a way to wake up those meditating threads","width":354},{"text":"how do we do that?","width":214},{"text":"yes broadcast, we want to not just wake up one sleeping thread with a little bell, ding","width":615},{"text":"right, if you call pthread_condition_signal the system will choose one arbitrary sleeping thread and wake it up","width":713},{"text":"we don't want to do that, we want to wake up everybody","width":300},{"text":"so this is like running over to FARPAR and shouting free ice cream right? everybody comes over","width":545},{"text":"actually any free food at FARPAR will work but so","width":244},{"text":"how can we do this? well here's what we'll do","width":263},{"text":"inside our code, we need to call broadcast","width":346},{"text":"now I could do it even before the while loop here","width":371},{"text":"I could say \"okay pthread_condition_broadcast\" and here's the way we're going to wake up, anybody who is sleeping on this particular conditional variable","width":993},{"text":"now will this work? yes, here's what happens","width":297},{"text":"you wake up everybody in FARPAR and they check and discover that actually there is no ice cream so they just go back to sleep","width":530},{"text":"okay so that's a silly analogy, but what happens in the code is that we wake up everybody inside the condition wait and see look we wrote it inside a while loop","width":544},{"text":"so everybody wakes up, eventually they get to run on the CPU, and when they do they'll say \"oh look remain is actually still greater than zero\"","width":555},{"text":"so this code will keep waking up every time a thread gets to this point, it would run it","width":301},{"text":"so we could do a bit better than that","width":111},{"text":"we actually don't want to always wake people, we actually only want to call this when we know that if remain is now zero, actually bother to wake people up","width":1244},{"text":"alright so if I'm the last person in the gate, wake everybody up","width":271},{"text":"there's no point in waking other people up beforehand because they will simply check and discover that remain is actually still non zero and then just go back to sleep","width":601},{"text":"so that would work, it's just not that efficient","width":250},{"text":"this is more efficient, don't wake people up until remain is zero","width":575},{"text":"so that is a barrier, yes at the back?","width":809},{"text":"well the last thread will see the value of zero so you'll never actually go into this while loop","width":297},{"text":"yes I could have written it afterwards, it's still a good idea to do the broadcast inside the lock and unlock","width":643},{"text":"there's a subtle race condition we can get if we don't","width":373},{"text":"right and the other thing to remember is that condition wait actually does three things","width":369},{"text":"after being woken up from its deep sleep, before it returns, it waits to acquire the mutex lock again","width":635},{"text":"so that means you've woken people up but they won't actually start to execute this code","width":349},{"text":"they won't be checking the remain value until someone exits","width":326},{"text":"until someone unlocks the mutex","width":191},{"text":"so in this case the sixteenth thread will come in, see that remain is now zero, wake everyone up","width":322},{"text":"but now they've woken up but can't actually continue on this code yet because we're still holding the mutex lock","width":510},{"text":"so eventually we unlock and then another thread in here will say great!","width":257},{"text":"finally I've woken up and finally I've managed to lock the mutex thread and I can continue","width":266},{"text":"and what's it do? it just unlocks the mutex and continues","width":203},{"text":"and so on and so on for the remaining threads","width":265},{"text":"so this is really really powerful","width":128},{"text":"this is a very very powerful paradigm now because now you can make your threads do a whole lot of work, pause for each other, wait for each other and then continue to do more work, etc","width":575},{"text":"now you can write pretty good performant code in a way that you couldn't before","width":481},{"text":"okay any other questions?","width":173},{"text":"I'll give you a hint, I like to do things like show you code and say on an exam or quiz and say \"well okay does this actually work? is it efficient or not? or when might it break?\"","width":906},{"text":"so you could imagine for example if we only did signal here instead of broadcast, we'd only be waking up one thread","width":479},{"text":"and the other fourteen of them would still be sleeping","width":561},{"text":"aha right so when we come to test this, A will be compiled so let's fix what you said","width":581},{"text":"pthread_cond_t there we go and then when we come to test it, it doesn't work","width":611},{"text":"what did we forget to do?","width":128},{"text":"initialize it, yes! remember with these things, we've actually got two steps","width":343},{"text":"you've got to A. make some memory somewhere of enough size and B. actually call init on it","width":414},{"text":"so inside here we need to do pthread_cond_init and if we were writing robust code, that's a null as well, we would check the return values of these","width":1555}]