[{"text":"hello welcome","width":63},{"text":"let's talk about getline","width":63},{"text":"so it's very common to read in a single line of text either from the user or from a file","width":443},{"text":"and we would like it to be very easy to say hey let's not worry about making sure my buffer is large enough","width":384},{"text":"i just want to get the whole line","width":125},{"text":"and thus getline was born","width":127},{"text":"this is being adopted into the posix standard","width":189},{"text":"if you are working however with an old standard and an older compiler we have to ask gcc to explicitly enable it","width":511},{"text":"so before doing our includes with stdio we need to define _GNU_SOURCE","width":510},{"text":"so if we do that we would like the gnu source additions to the standard functions","width":509},{"text":"right so if we do that now we have got a getline declaration included as part of the #include <stdio.h>","width":512},{"text":"so here is how we can use getline","width":187},{"text":"with getline we actually set up two variables","width":320},{"text":"we get getline to manipulate these directly ","width":255},{"text":"we are going to have a pointer to a buffer","width":250},{"text":"and a little int to say how big is our buffer","width":449},{"text":"well let's just check to see really if it is an int or if we should be doing a different type","width":255},{"text":"so let me pull up my favorite manpage on getline","width":253},{"text":"so actually the correct type to use is size_t","width":448},{"text":"which is essentially an unsigned int or larger on some systems","width":318},{"text":"so let's just make a note of that","width":99},{"text":"that is the declaration that we are going to be using","width":153},{"text":"and so we will have not just a buffer to our character array","width":377},{"text":"but also size as well to say how big is our buffer","width":316},{"text":"and i will call this say capacity","width":195},{"text":"right so we could start calling this and we could say okay","width":256},{"text":"get me a line and oh i need to pass in a pointer to my buffer variable","width":441},{"text":"right and notice that the declaration here is star star asteric so it's a pointer to a pointer","width":513},{"text":"right so how did i get that","width":126},{"text":"i say okay give me the address of my variable","width":191},{"text":"and similarly for the capacity as well","width":188},{"text":"the size of the variable","width":126},{"text":"so give me the address of my capacity","width":321},{"text":"and getline is going to modify those two variables directly","width":187},{"text":"essentially if my buffer is not large enough","width":189},{"text":"it is going to free up the old buffer and then call malloc so that we get a larger buffer","width":513},{"text":"okay technically it might call realloc but let's not worry about exactly which library call it calls","width":317},{"text":"we just know that it's going to do all that buffer maintenance for us automatically","width":319},{"text":"and now we need to give it a filestream so why don't we use say stdin","width":316},{"text":"so right now our code suffers from a terrible flaw which is that we've assumed that our automatic variables buffer capacity will be set to nothing","width":580},{"text":"so the getline knows that it can't reuse what it happens to be pointing to","width":313},{"text":"so we actually need to set these to explicitly to null and the capacity to zero","width":381},{"text":"so the first time we call getline getline will see that the buffer is certainly not large enough and will allocate enough space","width":447},{"text":"we can now find out what the result is which is the number of characters getline has managed to retrieve","width":573},{"text":"or a negative value if it failed","width":127},{"text":"so let's make a note of that","width":189},{"text":"and we'll print this out","width":125},{"text":"so i'll print out an integer and let's have a look to see what we can find inside our buffer","width":445},{"text":"so we want the result and we want the buffer","width":194},{"text":"and lastly let's put a newline here","width":189},{"text":"okay so we'll run our little program here","width":126},{"text":"and now it's waiting for me to type something","width":383},{"text":"okay great so it says i have got six characters","width":446},{"text":"wait and i printed ABCDE","width":123},{"text":"actually the last character might be a newline character","width":320},{"text":"and quite often we don't actually need that","width":190},{"text":"so why don't we overwrite the very last character with null with a terminating byte","width":382},{"text":"so let's write the code for that","width":126},{"text":"first of all we only want to do that if we get at least one character back from getline","width":383},{"text":"so let's check that the result was positive","width":252},{"text":"and also we only want to do this if we are going to overwrite the last character which truly is a newline","width":446},{"text":"we could imagine for example reading from a file where the very last byte is not actually a newline","width":320},{"text":"so we should just check to see what we're going to write here","width":242},{"text":"so let's look inside our buffer and where do we want to look?","width":329},{"text":"well if we read one character than that would be at the beginning of the buffer","width":316},{"text":"so we need to look at result minus one","width":129},{"text":"so if that is equal to the character of a newline","width":317},{"text":"then let's truncate the string","width":320},{"text":"the easiest way to do that remember is strings are just terminated by zero","width":190},{"text":"so let's just put a zero directly into that byte","width":188},{"text":"so we are going to say at the same spot set that equal to zero","width":383},{"text":"right so let's run our program again","width":63},{"text":"okay so this time it read it correctly and in our printf we didn't get that unwanted extra newline","width":957},{"text":"alright our program right now is allocating memory on the heap","width":317},{"text":"we don't do it we let getline do it","width":127},{"text":"but it's actually up to us when we finish using getline to free that buffer","width":316},{"text":"right so let's do that","width":192},{"text":"at the very end here we can call free on the buffer","width":316},{"text":"we don't need to do that every time we call getline because getline by default will try to for performance try to reuse the buffer for each line it gets","width":576},{"text":"so for example we could call getline twice and it would try to use the same buffer","width":511},{"text":"but the big take home message for getline is first of all","width":186},{"text":"you are going to need a pointer to a buffer and a capacity variacle which getline itself is going to change the contents of","width":449},{"text":"as you call it it can make the buffer as large as","width":380},{"text":"each time you call getline it might change that buffer to point to some new memory if the buffer needs to be larger","width":383},{"text":"secondly it's a great idea to check the return value of getline to see how many characters it managed to read","width":445},{"text":"and also to see if there was an error or not","width":190},{"text":"and the return type for that is ssize_t for a signed size integer type","width":446},{"text":"and finally it's good practice to don't forget to free the memory that is pointed at by your buffer variable","width":513},{"text":"okay that's it for me","width":126},{"text":"have fun playing bye","width":63}]