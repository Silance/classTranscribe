[{"text":"Let's see. I've heard the uiuc students are incredibly bright. Yes, they know how to party, but I've heard that you're really really bright","width":1170},{"text":"so let's see if you can actually solve this problem","width":273},{"text":"yes you're going to need some sort of flags or counters","width":533},{"text":"to keep track","width":377},{"text":"and rather than set them to one or zero","width":141},{"text":"we should add and subtract as people come in and want to read","width":308},{"text":"and I'll give you a clue: you're going to need some mutex locks","width":361},{"text":"at least one lock","width":102},{"text":"and some condition variables","width":1269},{"text":"we can start with one condition. let's do one condition variable","width":396},{"text":"you can add more if you want","width":93},{"text":"see if you can get something to kind of work with those","width":14756},{"text":"alright, let's have a go at grading the solution here","width":136},{"text":"I'm not gonna do the complete solution today","width":186},{"text":"I'm just trying to do this in stages","width":108},{"text":"we've seen two broken ones, I'm now going to try and write something which is a little less broken","width":371},{"text":"towards a complete solution","width":252},{"text":"we're going to be touching these variables so I'm going to use locks to make sure that when we access the values, it's actually read/written by one process at a time","width":935},{"text":"so now in reader, what we'll do is we'll see if we've got any writers trying to do anything","width":612},{"text":"then I want to wait","width":182},{"text":"but rather than having a busy loop, I'm going to meditate","width":263},{"text":"here we go, condition wait","width":196},{"text":"and I'll go to sleep","width":182},{"text":"so, if I come out of that, I'll check to see if there's any writers","width":157},{"text":"and if there are, then I'll go back to sleep again","width":392},{"text":"alright, before doing anything, I'm going to increment my little counter here. the number of readers has now gone up by one","width":591},{"text":"and then I can actually access the data structures so I'll do my reading here","width":469},{"text":"then I'll declare that \"hey! I finished! hey, there's no more readers\"","width":439},{"text":"and I can unlock","width":282},{"text":"the mutex","width":206},{"text":"yes, I can see that we've only going to actually allow one reader at a time, but trust me, for now this is a good stepping stone to a more complete solution","width":614},{"text":"what about the writers?","width":229},{"text":"well, they need to wait while there's any readers  (so any readers greaters than zero) or any writer greater than zero","width":573},{"text":"we want our writer to sleep","width":206},{"text":"great, I know a fantastic way to do that. let's call my cond_wait and pass in the pointer to the condition variable and a pointer to the mutex","width":625},{"text":"so we can only get out of this little loop once there's no other readers and no other writers","width":509},{"text":"before doing the writing, I'm going to increment my write count, then I'll do the writing","width":560},{"text":"afterwards, I'll decrement my write count and I'll unlock the mutex","width":1229},{"text":"I've got my readers and writers sleeping. if they are unable to continue, they'll sleep. we never wake them up.","width":674},{"text":"we....probably want to wake them up occasionally, yes?","width":393},{"text":"we could try to be clever when we should bash the gong","width":304},{"text":"when should we wake everybody up","width":132},{"text":"but I'm not going to do that right now","width":102},{"text":"I'm just going to put the code in down here that says \"well look, if I finish writing, maybe there's another writer waiting\"","width":596},{"text":"so hey, let me bash the gong here","width":157},{"text":"so pthread_cond_broadcast","width":542},{"text":"wake everybody up!","width":489},{"text":"alright, so, anybody that's sleeping, hey! wake up and check your condition, check your invariant, check the loop that you're inside","width":446},{"text":"do I need to do the same inside the read call as well?","width":1438},{"text":"so if there's a writer that is waiting, we should call p_cond_signal. could it be that I've got new readers in here?","width":1227},{"text":"cuz they might get the signal instead","width":104},{"text":"you can say \"okay! that's fine!\" or you might say \"actually that's impossible\" and never happen. even if it's impossible, they still end up signaling someone, so I could either call signal or broadcast here","width":1060},{"text":"so that's my next attempt. what do you think of it?","width":397},{"text":"it's better than the busy wait we saw a moment ago, but, what?","width":403},{"text":"thank you! right now, we've still got the problem of only one thread can actually do the reading because we lock the mutex.","width":470},{"text":"okay, we're going to have to fix that. other problems with it?","width":1305},{"text":"okay, so you're worried about mutual exclusion. actually, the beautiful thing is that our while loop will be checked each time and because we've got locks here, we can reason abotu this much more simply.","width":894},{"text":"because we locked this, we know that only one thread at a time can ever be executing inside this critical section, inside this code that we've written","width":1123},{"text":"hold on, I see what you're saying. but we're only incrementing the reader afterwards","width":275},{"text":"yeah, it's easy to see that initially, but remember we're going to wake these writers up but they don't actually check the values of r and w until","width":849},{"text":"we unlock the mutex","width":166},{"text":"okay so they're ready to go, they're about to run, but they don't get to return from this condition wait until we say so","width":493},{"text":"so they can only see a decremented version of the reader","width":635},{"text":"right so, we're heading towards a good solution but we've got more work to do","width":436},{"text":"one problem you might think about is, what would happen if I had a lot of readers?","width":539},{"text":"the poor writer is stuck! it never gets to change the data structure. readers barge in there and our read count never goes to zero","width":803},{"text":"so remember this magic saying called \"bounded wait\"?","width":230},{"text":"which is about, don't let the small kids just run in front of you?","width":297},{"text":"if you've been waiting, there should be a finite number of other processes to allow to continue before you get a fair chance","width":463},{"text":"we haven't succeeded in that yet either","width":210},{"text":"but anyways, this is towards a good solution","width":211},{"text":"so now, I need to change topic because first of all, you have a quiz on friday!","width":300},{"text":"woohoo!","width":63},{"text":"it's about memory allocation","width":276},{"text":"you can expect these kinds of questions!","width":225},{"text":"alright, does code data heap and stacks inside your memory?","width":372},{"text":"you know how to use pthread, and pthread_exit, and pthread_join and what the differences between pthread_exit and pthread_join","width":403},{"text":"you know what free(NULL) does. answer: nothing","width":274},{"text":"pthread_create succeeds, what does it return, zero, you get the id by giving it a pointer instead","width":350},{"text":"can you use a function that's not thread safe in a multithreaded program?","width":342},{"text":"what the answer? yes you can, but you've got to make sure only one thread at a time accesses it","width":570},{"text":"gosh, when do you knew about pthread_mutex_lock","width":164},{"text":"so yes you can, but you have to be careful","width":409},{"text":"pthread join man, okay, so enough about pthread_join","width":275},{"text":"boundary tags, oh yes! here's a memory allocator that we did not talk about in lecture","width":332},{"text":"but rather than making allocations the size that the user requests, we can have chunks which are 2^n sizes","width":972},{"text":"so if I have a pool of a 1024 bytes, we can split that into two allocations of 512, for example","width":657},{"text":"or I can split this 512 into two allocations of 256","width":341},{"text":"so if I keep my chunks at sizes 2^n","width":354},{"text":"then I can very quickly and efficiently find an allocation of the correct size","width":636},{"text":"so, for example, if I wanted 65 byte allocations, I would end up using allocations of 128 bytes","width":899},{"text":"and so, if I had 1024 bytes to play with, I could make eight of those allocations","width":375},{"text":"so you can see that this kind of allocator, which by the way is called the buddy allocator, suffers strongly from fragmentation","width":651},{"text":"I'm going to give you a block of 128 bytes, but you're only going to use 65 bytes of it","width":563},{"text":"so it can end up having a great bit of a unnecessary space, but the good news is that it's very very fast to find a free block of sufficient size","width":956},{"text":"implicit and explicit free lists? you've seen this now in the MP contest that we can have a separate list of free blocks","width":659},{"text":"so it's much much quicker to find a free block rather than scanning through a linked list of all free and allocated blocks, why not have a second linked list which only contains the free entries?","width":1038},{"text":"so that's an explicit free list","width":141},{"text":"and if we do that, we can put it inside the unused space","width":664},{"text":"okay so you know about first fit and worst fit and how they work","width":484},{"text":"and you know what malloc() and calloc() do if they can't return the request.","width":306},{"text":"alright good, I have a moment left","width":254},{"text":"good news and bad news. I've got some sad news for you in a sense. monday and wednesday, I'm going to be in california","width":802},{"text":"so, robin is going to be taking this lecture slot. and she's going to be talking about some 241 content","width":458},{"text":"you're in safe hands. she's taught this course before","width":176},{"text":"I'm talking about andriod mook and representing illinois at the coursera partners conference","width":471},{"text":"this course, which ran in december 2013, we the largest ever course by illinois","width":370},{"text":"at 143,000 people signed up. we've since had 200,000 people sign up","width":325}]