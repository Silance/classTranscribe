[{"start":"0:00","end":"0:20","text":"Let's see. I've heard the uiuc students are incredibly bright. Yes, they know how to party, but I've heard that you're really really bright"},{"start":"0:20","end":"0:23","text":"so let's see if you can actually solve this problem"},{"start":"0:23","end":"0:30","text":"yes you're going to need some sort of flags or counters"},{"start":"0:30","end":"0:37","text":"to keep track"},{"start":"0:37","end":"0:40","text":"and rather than set them to one or zero"},{"start":"0:40","end":"0:44","text":"we should add and subtract as people come in and want to read"},{"start":"0:44","end":"0:50","text":"and I'll give you a clue: you're going to need some mutex locks"},{"start":"0:50","end":"0:51","text":"at least one lock"},{"start":"0:51","end":"0:54","text":"and some condition variables"},{"start":"0:54","end":"1:17","text":"we can start with one condition. let's do one condition variable"},{"start":"1:17","end":"1:19","text":"you can add more if you want"},{"start":"1:19","end":"1:23","text":"see if you can get something to kind of work with those"},{"start":"1:23","end":"5:11","text":"alright, let's have a go at grading the solution here"},{"start":"5:11","end":"5:15","text":"I'm not gonna do the complete solution today"},{"start":"5:15","end":"5:16","text":"I'm just trying to do this in stages"},{"start":"5:16","end":"5:22","text":"we've seen two broken ones, I'm now going to try and write something which is a little less broken"},{"start":"5:22","end":"5:23","text":"towards a complete solution"},{"start":"5:23","end":"5:41","text":"we're going to be touching these variables so I'm going to use locks to make sure that when we access the values, it's actually read/written by one process at a time"},{"start":"5:41","end":"5:50","text":"so now in reader, what we'll do is we'll see if we've got any writers trying to do anything"},{"start":"5:50","end":"5:53","text":"then I want to wait"},{"start":"5:53","end":"5:56","text":"but rather than having a busy loop, I'm going to meditate"},{"start":"5:56","end":"5:59","text":"here we go, condition wait"},{"start":"5:59","end":"6:03","text":"and I'll go to sleep"},{"start":"6:03","end":"6:06","text":"so, if I come out of that, I'll check to see if there's any writers"},{"start":"6:06","end":"6:10","text":"and if there are, then I'll go back to sleep again"},{"start":"6:10","end":"6:21","text":"alright, before doing anything, I'm going to increment my little here. the number of readers has now gone up by one"},{"start":"6:21","end":"6:28","text":"and then I can actually access the data structures so I'll do my reading here"},{"start":"6:28","end":"6:37","text":"then I'll declare that \"hey! I finished! hey, there's no more readers\""},{"start":"6:37","end":"6:38","text":"and I can unlock"},{"start":"6:38","end":"6:41","text":"the mutex"},{"start":"6:41","end":"6:54","text":"yes, I can see that we've only going to actually allow one reader at a time, but trust me, for now this is a good stepping stone to a more complete solution"},{"start":"6:54","end":"6:56","text":"what about the writers?"},{"start":"6:56","end":"7:07","text":"well, they need to wait while there's any readers  (so any readers greaters than zero) or any writer greater than zero"},{"start":"7:07","end":"7:09","text":"we want our writer to sleep"},{"start":"7:09","end":"7:20","text":"great, I know a fantastic way to do that. let's call my cond_wait and pass in the pointer to the condition variable and a pointer to the mutex"},{"start":"7:20","end":"7:25","text":"so we can only get out of this little loop once there's no other readers and no other writers"},{"start":"7:25","end":"7:32","text":"before doing the writing, I'm going to increment my write count, then I'll do the writing"},{"start":"7:32","end":"7:41","text":"afterwards, I'll decrement my write count and I'll unlock the mutex"},{"start":"7:41","end":"8:04","text":"I've got my readers and writers sleeping. if they are unable to continue, they'll sleep. we never wake them up."},{"start":"8:04","end":"8:10","text":"we....probably want to wake them up occasionally, yes?"},{"start":"8:10","end":"8:16","text":"we could try to be clever when we should bash the gong"},{"start":"8:16","end":"8:19","text":"when should we wake everybody up"},{"start":"8:19","end":"8:21","text":"but I'm not going to do that right now"},{"start":"8:21","end":"8:29","text":"I'm just going to put the code in down here that says \"well look, if I finish writing, maybe there's another writer waiting\""},{"start":"8:29","end":"8:34","text":"so hey, let me bash the gong here"},{"start":"8:34","end":"8:40","text":"so pthread_cond_broadcast"},{"start":"8:40","end":"8:42","text":"wake everybody up!"},{"start":"8:42","end":"8:55","text":"alright, so, anybody that's sleeping, hey! wake up and check your condition, check your invariant, check the loop that you're inside"},{"start":"8:55","end":"8:59","text":"do I need to do the same inside the read call as well?"},{"start":"8:59","end":"9:33","text":"so if there's a writer that is waiting, we should call p_cond_signal. could it be that I've got new readers in here?"},{"start":"9:33","end":"9:40","text":"cuz they might get the signal instead"},{"start":"9:40","end":"9:53","text":"you can say \"okay! that's fine!\" or you might say \"actually that's impossible\" and never happen. even if it's impossible, they still end up signaling someone, so I could either call signal or broadcast here"},{"start":"9:53","end":"10:00","text":"so that's my next attempt. what do you think of it?"},{"start":"10:00","end":"10:07","text":"it's better than the busy wait we saw a moment ago, but, what?"},{"start":"10:07","end":"10:17","text":"thank you! right now, we've still got the problem of only one thread can actually do the reading because we lock the mutex."},{"start":"10:17","end":"10:20","text":"okay, we're going to have to fix that. other problems with it?"},{"start":"10:20","end":"10:51","text":"okay, so you're worried about mutual ____. actually, the beautiful thing is that our while loop will be checked each time and because we've got locks here, we can reason abotu this much more simply."},{"start":"10:51","end":"10:58","text":"because we locked this, we know that only one thread at a time can ever be executing inside this critical section, inside this code that we've written"},{"start":"10:58","end":"11:11","text":"hold on, I see what you're saying. but we're only incrementing the reader afterwards"},{"start":"11:11","end":"11:23","text":"yeah, it's easy to see that initially, but remember we're going to wake these writers up but they don't actually check the values of r and w until"},{"start":"11:23","end":"11:27","text":"we unlock the mutex"},{"start":"11:27","end":"11:34","text":"okay so they're ready to go, they're about to run, but they don't get to return from this condition wait until we say so"},{"start":"11:34","end":"11:42","text":"so they can only see a decremented version of the reader"},{"start":"11:42","end":"11:53","text":"right so, we're heading towards a good solution but we've got more work to do"},{"start":"11:53","end":"11:56","text":"one problem you might think about is, what would happen if I had a lot of readers?"},{"start":"11:56","end":"12:13","text":"the poor writer is stuck! it never gets to change the data structure. readers barge in there and our read count never goes to zero"},{"start":"12:13","end":"12:17","text":"so remember this magic saying called \"bounded wait\"?"},{"start":"12:17","end":"12:22","text":"which is about, don't let the small kids just run in front of you?"},{"start":"12:22","end":"12:30","text":"if you've been waiting, there should be a finite number of other processes to allow to continue before you get a fair chance"},{"start":"12:30","end":"12:34","text":"we haven't succeeded in that yet either"},{"start":"12:34","end":"12:35","text":"but anyways, this is towards a good solution"},{"start":"12:35","end":"12:38","text":"so now, I need to change topic because first of all, you have a quiz on friday!"},{"start":"12:38","end":"12:40","text":"woohoo!"},{"start":"12:40","end":"12:43","text":"it's about memory allocation"},{"start":"12:43","end":"12:49","text":"you can expect these kinds of questions!"},{"start":"12:49","end":"12:54","text":"alright, does code data heap and stacks inside your memory?"},{"start":"12:54","end":"13:02","text":"you know how to use pthread, and pthread_exit, and pthread_join and what the differences between pthread_exit and pthread_join"},{"start":"13:02","end":"13:05","text":"you know what free(NULL) does. answer: nothing"},{"start":"13:05","end":"13:11","text":"pthread_create succeeds, what does it return, zero, you get the id by giving it a pointer instead"},{"start":"13:11","end":"13:16","text":"can you use a function that's not thread safe in a multithreaded program?"},{"start":"13:16","end":"13:26","text":"what the answer? yes you can, but you've got to make sure only one thread at a time accesses it"},{"start":"13:26","end":"13:27","text":"gosh, when do you knew about pthread_mutex_lock"},{"start":"13:27","end":"13:31","text":"so yes you can, but you have to be careful"},{"start":"13:31","end":"13:38","text":"pthread join man, okay, so enough about pthread_join"},{"start":"13:38","end":"13:42","text":"boundary tags, oh yes! here's a memory allocator that we did not talk about in lecture"},{"start":"13:42","end":"13:58","text":"but rather than making allocations the size that the user requests, we can have chunks which are 2^n sizes"},{"start":"13:58","end":"14:08","text":"so if I have a pool of a 1024 bytes, we can split that into two allocations of 512, for example"},{"start":"14:08","end":"14:14","text":"or I can split this 512 into two allocations of 256"},{"start":"14:14","end":"14:21","text":"so if I keep my chunks at sizes 2^n"},{"start":"14:21","end":"14:30","text":"then I can very quickly and efficiently find an allocation of the correct size"},{"start":"14:30","end":"14:43","text":"so, for example, if I wanted 65 byte allocations, I would end up using allocations of 128 bytes"},{"start":"14:43","end":"14:50","text":"and so, if I had 1024 bytes to play with, I could make eight of those allocations"},{"start":"14:50","end":"15:05","text":"so you can see that this kind of allocator, which by the way is called the buddy allocator, suffers strongly from fragmentation"},{"start":"15:05","end":"15:15","text":"I'm going to give you a block of 128 bytes, but you're only going to use 65 bytes of it"},{"start":"15:15","end":"15:20","text":"so it can end up having a great bit of a unnecessary space, but the good news is that it's very very fast to find a free block of sufficient size"},{"start":"15:20","end":"15:36","text":"implicit and explicit free lists? you've seen this now in the MP contest that we can have a separate list of free blcosk"},{"start":"15:36","end":"15:51","text":"so it's much much quicker to find a free block rather than scanning through a linked list of all free and allocated blocks, why not have a second linked list which only contains the free entries?"},{"start":"15:51","end":"15:53","text":"so that's an explicit free list"},{"start":"15:53","end":"16:01","text":"and if we do that, we can put it inside the unused space"},{"start":"16:01","end":"16:11","text":"okay so you know about first fit and worst fit and how they work"},{"start":"16:11","end":"16:15","text":"and you know what malloc() and calloc() do if they can't return the request."},{"start":"16:15","end":"16:21","text":"alright good, I have a moment left"},{"start":"16:21","end":"16:31","text":"good news and bad news. I've got some sad news for you in a sense. monday and wednesday, I'm going to be in california"},{"start":"16:31","end":"16:42","text":"so, robin is going to be taking this lecture slot. and she's going to be talking about some 241 content"},{"start":"16:42","end":"16:43","text":"you're in safe hands. she's taught this course before"},{"start":"16:43","end":"16:50","text":"I'm talking about andriod mook and representing illinois at the coursera partners conference"},{"start":"16:50","end":"16:55","text":"this course, which ran in december 2013, we the largest ever course by illinois"},{"start":"16:55","end":"16:59","text":"at 143,000 people signed up. we've since had 200,000 people sign up"}]